import { createClientFromRequest } from 'npm:@base44/sdk@0.7.0';\n\n// === AUTOENCODEUR TRIANGULAIRE FRACTAL ===\n// Systeme revolutionnaire de generation de code 110% parfait\nclass TriangularCognitiveForge {\n  constructor(base44) {\n      this.base44 = base44;\n      this.triangulationMethods = ['security_validator', 'performance_optimizer', 'architecture_analyst'];\n      this.currentRotation = 0;\n      this.memoryCache = null;\n      this.fractalValidationThreshold = 95; // Seuil plus eleve pour perfection\n  }\n\n  // Charger TOUTE la memoire systeme dans le cache\n  async loadSystemMemoryCache() {\n      if (this.memoryCache) return this.memoryCache;\n      \n      try {\n          console.log('[B] Chargement du cache memoire systeme complet...');\n          \n          // Recuperer TOUS les fragments cognitifs\n          const cognitiveFragments = await this.base44.asServiceRole.entities.CognitiveFragment.list();\n          \n          // Recuperer TOUS les fragments de code\n          const codeFragments = await this.base44.asServiceRole.entities.CodeFragment.list();\n          \n          // Recuperer TOUTES les versions de fichiers\n          const fileVersions = await this.base44.asServiceRole.entities.FileVersion.list();\n          \n          // Recuperer les parametres AURORA pour le contexte\n          const auroraSettings = await this.base44.asServiceRole.entities.GlobalSetting.filter({});\n          
          this.memoryCache = {\n              cognitive_fragments: cognitiveFragments,\n              code_fragments: codeFragments,\n              file_versions: fileVersions,\n              aurora_settings: auroraSettings,\n              system_knowledge: this.extractSystemKnowledge(cognitiveFragments, codeFragments),\n              cached_at: new Date().toISOString()\n          };\n          \n          console.log(`[C] Cache memoire charge: ${cognitiveFragments.length} fragments cognitifs, ${codeFragments.length} fragments code`);\n          return this.memoryCache;\n          \n      } catch (error) {\n          console.error('Erreur chargement cache memoire:', error);\n          // IMPORTANT: Return an object with an error, don't set this.memoryCache to null or throw,\n          // so generatePerfectCode can handle it.\n          this.memoryCache = { error: error.message }; // Set an error state in cache\n          return this.memoryCache;\n      }\n  }\n\n  // Extraire la connaissance systeme structuree\n  extractSystemKnowledge(cognitiveFragments, codeFragments) {\n      const knowledge = {\n          patterns: [],\n          architectures: [],\n          security_rules: [],\n          performance_tips: [],\n          common_errors: []\n      };\n      \n      // Analyser les fragments cognitifs\n      cognitiveFragments.forEach(fragment => {\n          try {\n              const metadata = JSON.parse(fragment.metadata || '{}');\n              \n              if (metadata.type === 'pattern') {\n                  knowledge.patterns.push({\n                      content: fragment.content_text,\n                      tags: fragment.dimension_tags,\n                      score: fragment.fractal_score\n                  });\n              }\n              \n              if (metadata.type === 'architecture') {\n                  knowledge.architectures.push({\n                      content: fragment.content_text,\n                      complexity: fragment.fractal_score\n                  });\n              }\n              \n              if (fragment.dimension_tags?.includes('security')) {\n                  knowledge.security_rules.push(fragment.content_text);\n              }\n              \n          } catch (e) {\n              // Skip malformed fragments\n          }\n      });\n      \n      // Analyser les fragments de code\n      codeFragments.forEach(fragment => {\n          if (fragment.fragment_type === 'security_patch') {\n              knowledge.security_rules.push(fragment.code_content);\n          }\n          \n          if (fragment.fragment_type === 'optimization') {\n              knowledge.performance_tips.push(fragment.code_content);\n          }\n      });\n      \n      return knowledge;\n  }\n\n  // Triangulation fractale : 3 LLMs avec des roles rotatifs\n  async triangularValidation(codeToValidate, problemContext) {\n      await this.loadSystemMemoryCache();\n      \n      // Verifier que le cache a ete charge sans erreur\n      if (!this.memoryCache || this.memoryCache.error) {\n          throw new Error(`Impossible d'effectuer la validation triangulaire: ${this.memoryCache?.error || 'Cache memoire non charge.'}`);\n      }\n\n      const validators = [];\n      const rotationOrder = this.getRotationOrder();\n      \n      // Chaque validateur a un angle d'approche different\n      for (let i = 0; i < 3; i++) {\n          const validatorRole = rotationOrder[i];\n          const validation = await this.runValidatorWithRole(codeToValidate, problemContext, validatorRole, i);\n          validators.push({\n              role: validatorRole,\n              angle: i * 120, // 360deg / 3 = 120deg\n              ...validation\n          });\n      }\n      \n      // Analyse fractale des resultats\n      const fractalAnalysis = this.analyzeFractalConsensus(validators);\n      \n      // Rotation pour la prochaine utilisation\n      this.rotateValidators();\n      
      return {\n          triangular_validation: validators,\n          fractal_consensus: fractalAnalysis,\n          final_score: fractalAnalysis.consensus_score,\n          approved: fractalAnalysis.consensus_score >= this.fractalValidationThreshold\n      };\n  }\n\n  // Obtenir l'ordre de rotation actuel\n  getRotationOrder() {\n      const base = ['security_validator', 'performance_optimizer', 'architecture_analyst'];\n      const rotated = [];\n      \n      for (let i = 0; i < 3; i++) {\n          rotated.push(base[(this.currentRotation + i) % 3]);\n      }\n      \n      return rotated;\n  }\n\n  // Executer un validateur avec un role specifique\n  async runValidatorWithRole(code, context, role, angleIndex) {\n      const systemKnowledge = this.memoryCache.system_knowledge;\n      \n      let rolePrompt = '';\n      let relevantKnowledge = '';\n      \n      switch (role) {\n          case 'security_validator':\n              rolePrompt = `Tu es un expert en cybersecurite. Analyse ce code pour detecter toute vulnerabilite, faille de securite, ou risque potentiel.`;\n              relevantKnowledge = systemKnowledge.security_rules.join('\n');\n              break;\n              \n          case 'performance_optimizer':\n              rolePrompt = `Tu es un expert en optimisation de performance. Analyse ce code pour detecter les goulots d'etranglement, les inefficacites, et propose des ameliorations.`;\n              relevantKnowledge = systemKnowledge.performance_tips.join('\n');\n              break;\n              \n          case 'architecture_analyst':\n              rolePrompt = `Tu es un architecte logiciel expert. Analyse ce code pour verifier sa coherence architecturale, sa maintenabilite, et sa conformite aux bonnes pratiques.`;\n              relevantKnowledge = systemKnowledge.patterns.map(p => p.content).join('\n');\n              break;\n      }\n\n      const validationPrompt = `\n  ${rolePrompt}\n\n  CONTEXTE DU PROBLEME: ${context}\n\n  CONNAISSANCE SYSTEME PERTINENTE:\n  ${relevantKnowledge.substring(0, 3000)}\n\n  CODE A ANALYSER:\n  ${code}\n\n  ANGLE D'ANALYSE: ${angleIndex * 120}deg (Perspective ${role})\n\n  Reponds en JSON avec cette structure exacte:\n  {\n  \"role_score\": number (0-100),\n  \"critical_issues\": [\"liste des problemes critiques\"],\n  \"improvements\": [\"suggestions d'amelioration\"],\n  \"security_rating\": number (0-10),\n  \"performance_rating\": number (0-10),\n  \"architecture_rating\": number (0-10),\n  \"detailed_analysis\": \"analyse detaillee de ton expertise\",\n  \"confidence\": number (0-1)\n  }\n        `;\n
      try {\n          const result = await this.base44.integrations.Core.InvokeLLM({\n              prompt: validationPrompt,\n              response_json_schema: {\n                  type: "object",\n                  properties: {\n                      role_score: { type: "number" },\n                      critical_issues: { type: "array", items: { type: "string" } },\n                      improvements: { type: "array", items: { type: "string" } },\n                      security_rating: { type: "number" },\n                      performance_rating: { type: "number" },\n                      architecture_rating: { type: "number" },\n                      detailed_analysis: { type: "string" },\n                      confidence: { type: "number" }\n                  }\n              }\n          });\n\n          return result;\n          \n      } catch (error) {\n          return {\n              role_score: 0,\n              critical_issues: [`Erreur validation ${role}: ${error.message}`],\n              improvements: [],\n              security_rating: 0,\n              performance_rating: 0,\n              architecture_rating: 0,\n              detailed_analysis: `Echec de validation: ${error.message}`,
              confidence: 0\n          };\n      }\n  }\n\n  // Analyser le consensus fractal des 3 validateurs\n  analyzeFractalConsensus(validators) {\n      // Scores moyens\n      const avgScore = validators.reduce((sum, v) => sum + v.role_score, 0) / validators.length;\n      const avgSecurity = validators.reduce((sum, v) => sum + v.security_rating, 0) / validators.length;\n      const avgPerformance = validators.reduce((sum, v) => sum + v.performance_rating, 0) / validators.length;\n      const avgArchitecture = validators.reduce((sum, v) => sum + v.architecture_rating, 0) / validators.length;\n      \n      // Convergence fractale (plus les scores sont proches, plus la convergence est forte)\n      const scoreVariance = this.calculateVariance(validators.map(v => v.role_score));\n      const convergence = Math.max(0, 1 - (scoreVariance / 100));\n      \n      // Issues critiques uniques\n      const allCriticalIssues = validators.flatMap(v => v.critical_issues);\n      const uniqueCriticalIssues = [...new Set(allCriticalIssues)];\n      \n      // Toutes les ameliorations\n      const allImprovements = validators.flatMap(v => v.improvements);\n      const uniqueImprovements = [...new Set(allImprovements)];\n      \n      // Score de consensus fractal (formule custom)\n      const fractalWeight = convergence * 0.4; // 40% pour la convergence\n      const qualityWeight = (avgSecurity + avgPerformance + avgArchitecture) / 3 * 10 * 0.6; // 60% pour la qualite\n      const consensusScore = fractalWeight * 100 + qualityWeight;\n      \n      return {\n          consensus_score: Math.min(100, Math.round(consensusScore)),\n          convergence_rate: Math.round(convergence * 100),\n          average_ratings: {\n              security: Math.round(avgSecurity * 10),\n              performance: Math.round(avgPerformance * 10),\n              architecture: Math.round(avgArchitecture * 10)\n          },\n          critical_issues: uniqueCriticalIssues,\n          improvements: uniqueImprovements,\n          fractal_stability: scoreVariance < 25 ? 'stable' : scoreVariance < 50 ? 'moderate' : 'unstable'\n      };\n  }\n
  // Calculer la variance des scores\n  calculateVariance(scores) {\n      const mean = scores.reduce((sum, score) => sum + score, 0) / scores.length;\n      const squaredDiffs = scores.map(score => Math.pow(score - mean, 2));\n      return squaredDiffs.reduce((sum, diff) => sum + diff, 0) / scores.length;\n  }\n
  // Faire une rotation des validateurs pour eviter les biais\n  rotateValidators() {\n      this.currentRotation = (this.currentRotation + 1) % 3;\n  }\n
  // Generer du code 110% parfait en utilisant la triangulation\n  async generatePerfectCode(problemDescription, contextData = {}) {\n      try {\n          console.log('[T] TRIANGULAR COGNITIVE FORGE: Generation de code 110% parfait...');\n          \n          await this.loadSystemMemoryCache();\n          \n          // Verifier que le cache a ete charge sans erreur\n          if (!this.memoryCache || this.memoryCache.error) {\n              throw new Error(`Impossible de generer le code parfait: ${this.memoryCache?.error || 'Cache memoire non charge.'}`);\n          }\n          \n          // Phase 1: Generation initiale basee sur la memoire systeme\n          const initialCode = await this.generateFromSystemMemory(problemDescription);\n          \n          // Phase 2: Validation triangulaire\n          const triangularValidation = await this.triangularValidation(initialCode, problemDescription);\n          \n          if (!triangularValidation.approved) {\n              // Phase 3: Amelioration iterative basee sur les suggestions\n              const improvedCode = await this.improveCodeWithSuggestions(\n                  initialCode, \n                  triangularValidation.fractal_consensus.improvements,\n                  problemDescription\n              );\n              \n              // Phase 4: Re-validation du code ameliore\n              const finalValidation = await this.triangularValidation(improvedCode, problemDescription);\n              \n              return {\n                  success: finalValidation.approved,\n                  generated_code: improvedCode,\n                  validation_results: finalValidation,\n                  iterations: 2,\n                  perfection_score: finalValidation.final_score\n              };\n          }\n          \n          return {\n              success: true,\n              generated_code: initialCode,\n              validation_results: triangularValidation,\n              iterations: 1,\n              perfection_score: triangularValidation.final_score\n          };\n          \n      } catch (error) {\n          console.error('Erreur Triangular Cognitive Forge:', error);\n          return { success: false, error: error.message };\n      }\n  }\n
  // Generer le code initial base sur la memoire systeme\n  async generateFromSystemMemory(problemDescription) {\n      const systemKnowledge = this.memoryCache.system_knowledge;\n      \n      // Trouver les patterns les plus pertinents\n      const relevantPatterns = systemKnowledge.patterns\n          .filter(p => p.tags.some(tag => problemDescription.toLowerCase().includes(tag.toLowerCase())))\n          .sort((a, b) => b.score - a.score)\n          .slice(0, 3);\n      
      // Trouver les architectures pertinentes\n      const relevantArchitectures = systemKnowledge.architectures\n          .sort((a, b) => b.complexity - a.complexity)\n          .slice(0, 2);\n
      const generationPrompt = `\n  MISSION: Generer du code JavaScript/Deno de qualite PRODUCTION pour resoudre: \"${problemDescription}\"\n\n  PATTERNS SYSTEME PERTINENTS:\n  ${relevantPatterns.map((p, i) => `Pattern ${i+1}: ${p.content}`).join('\n\n')}\n\n  ARCHITECTURES REFERENCE:\n  ${relevantArchitectures.map((a, i) => `Architecture ${i+1}: ${a.content}`).join('\n\n')}\n\n  REGLES DE SECURITE SYSTEME:\n  ${systemKnowledge.security_rules.slice(0, 3).join('\n')}\n\n  OPTIMISATIONS PERFORMANCE:\n  ${systemKnowledge.performance_tips.slice(0, 3).join('\n')}\n\n  Instructions CRITIQUES:\n  1. Utilise EXACTEMENT la structure Deno.serve() pour les fonctions\n  2. Implemente createClientFromRequest() pour Base44 SDK\n  3. Ajoute une gestion d'erreur ROBUSTE\n  4. Optimise pour la PERFORMANCE et la SECURITE\n  5. Code PRODUCTION-READY, pas de TODO ni placeholder\n  6. Respecte les patterns systeme identifies\n
  GENERE MAINTENANT LE CODE PARFAIT:\n        `;\n
      const generatedCode = await this.base44.integrations.Core.InvokeLLM({\n          prompt: generationPrompt\n      });\n
      return generatedCode;\n  }\n
  // Ameliorer le code avec les suggestions triangulaires\n  async improveCodeWithSuggestions(originalCode, suggestions, problemDescription) {\n      const improvementPrompt = `\n  CODE ORIGINAL:\n  ${originalCode}\n\n  PROBLEME A RESOUDRE: ${problemDescription}\n\n  AMELIORATIONS SUGGEREES PAR LA TRIANGULATION FRACTALE:\n  ${suggestions.map((s, i) => `${i+1}. ${s}`).join('\n')}\n\n  MISSION: Reecrire le code en appliquant TOUTES ces ameliorations pour atteindre la perfection 110%.\n\n  Assure-toi que:\n  - Toutes les suggestions sont implementees\n  - Le code reste fonctionnel et coherent\n  - La structure Deno.serve() est preservee\n  - Aucune regression n'est introduite\n
  CODE AMELIORE:\n        `;\n
      const improvedCode = await this.base44.integrations.Core.InvokeLLM({\n          prompt: improvementPrompt\n      });\n
      return improvedCode;\n  }\n}

Deno.serve(async (req) => {
  try {\n      const base44 = createClientFromRequest(req);\n      const user = await base44.auth.me();\n      \n      const adminEmail = Deno.env.get('WM_AI');\n      if (!user || (user.email !== adminEmail && user.email !== 'aurora@pxshop.cai')) {\n          return Response.json({ error: 'Acces restreint au Forge Triangulaire' }, { status: 403 });\n      }\n      \n      const { operation, ...params } = await req.json();\n      const triangularForge = new TriangularCognitiveForge(base44);\n      \n      let result;\n      switch (operation) {\n          case 'generate_perfect_code':\n              result = await triangularForge.generatePerfectCode(\n                  params.problem_description,\n                  params.context_data || {}
              );\n              break;\n              \n          case 'validate_triangular':\n              result = await triangularForge.triangularValidation(\n                  params.code,\n                  params.context
              );\n              break;\n              \n          case 'load_system_memory':\n              result = await triangularForge.loadSystemMemoryCache();\n              break;\n              \n          default:\n              return Response.json({ error: 'Operation non reconnue' }, { status: 400 });\n      }\n      \n      return Response.json(result);\n      \n  } catch (error) {\n      console.error('Erreur Triangular Cognitive Forge:', error);\n      return Response.json({ error: `Forge Triangulaire: ${error.message}` }, { status: 500 });\n  }\n});