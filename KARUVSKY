<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>CAR UltraViolet — Système Cognitif Quantique Avancé v2025</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    * { box-sizing: border-box; }
    body { 
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 50%, #2a1f3a 100%); 
      color: #f9f9ff; 
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace; 
      margin: 0; 
      min-height: 100vh;
      overflow-x: hidden;
    }
    
    #interface { 
      max-width: 1200px; 
      margin: 2vh auto; 
      background: linear-gradient(145deg, #1e2436 0%, #2a3245 100%);
      border-radius: 28px; 
      box-shadow: 0 15px 80px rgba(0,0,0,0.6), 0 0 40px rgba(124,77,255,0.2);
      padding: 40px 35px; 
      position: relative;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(124,77,255,0.3);
    }
    
    .header-panel {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 25px;
      padding: 15px 25px;
      background: linear-gradient(90deg, #7c4dff 0%, #b388ff 100%);
      border-radius: 15px;
      box-shadow: 0 5px 20px rgba(124,77,255,0.4);
    }
    
    .logo {
      font-size: 1.8em;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .system-status {
      display: flex;
      gap: 15px;
      align-items: center;
    }
    
    .status-indicator {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #43e684;
      box-shadow: 0 0 15px #43e684;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.2); }
    }
    
    .quantum-vortex-container {
      position: relative;
      display: flex;
      justify-content: center;
      margin: 25px 0;
    }
    
    #vortex { 
      display: block; 
      background: radial-gradient(circle, #0a0e1a 0%, #1a1f2e 100%);
      border-radius: 50%; 
      box-shadow: 0 0 60px rgba(124,77,255,0.6), inset 0 0 40px rgba(0,0,0,0.8);
      border: 2px solid rgba(124,77,255,0.4);
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #vortex:hover {
      transform: scale(1.05);
      box-shadow: 0 0 80px rgba(124,77,255,0.8);
    }
    
    .control-panel {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin: 25px 0;
    }
    
    .panel-section {
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      border-radius: 15px;
      padding: 20px;
      border: 1px solid rgba(124,77,255,0.2);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    .panel-title {
      font-size: 1.1em;
      font-weight: bold;
      color: #b388ff;
      margin-bottom: 15px;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    #chat { 
      min-height: 200px; 
      max-height: 400px;
      margin-bottom: 20px; 
      white-space: pre-wrap; 
      font-size: 1.02em; 
      overflow-y: auto;
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      border-radius: 12px;
      padding: 20px;
      border: 1px solid rgba(124,77,255,0.2);
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .user { color: #64b5f6; font-weight: bold; }
    .bot { color: #ffe066; }
    .wiki { color: #aef46c; }
    .wikisrc { color: #43e684; background: rgba(67,230,132,0.1); padding: 2px 6px; border-radius: 4px; }
    .uv { color: #d500f9; font-weight: bold; text-shadow: 0 0 8px #d500f9; }
    .memory { color: #b3e5fc; }
    .mutation { 
      color: #ffeb3b; 
      background: linear-gradient(135deg, #2a2a2a 0%, #3a3a3a 100%);
      border-radius: 8px; 
      padding: 8px 12px; 
      margin: 8px 0; 
      display: inline-block;
      border-left: 4px solid #ffeb3b;
      box-shadow: 0 2px 10px rgba(255,235,59,0.2);
    }
    .introspection { 
      color: #90caf9; 
      background: linear-gradient(135deg, #1a237e 0%, #283593 100%);
      border-radius: 8px; 
      padding: 8px 12px; 
      margin: 8px 0; 
      display: inline-block;
      border-left: 4px solid #90caf9;
      box-shadow: 0 2px 10px rgba(144,202,249,0.3);
    }
    
    .advanced-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }
    
    .control-btn {
      background: linear-gradient(135deg, #7c4dff 0%, #9c27b0 100%);
      color: #fff;
      border: none;
      border-radius: 8px;
      padding: 8px 16px;
      font-size: 0.9em;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 3px 15px rgba(124,77,255,0.3);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-weight: 600;
    }
    
    .control-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124,77,255,0.4);
      background: linear-gradient(135deg, #9c27b0 0%, #7c4dff 100%);
    }
    
    .control-btn.secondary {
      background: linear-gradient(135deg, #43e684 0%, #4caf50 100%);
      box-shadow: 0 3px 15px rgba(67,230,132,0.3);
    }
    
    .control-btn.secondary:hover {
      background: linear-gradient(135deg, #4caf50 0%, #43e684 100%);
      box-shadow: 0 5px 20px rgba(67,230,132,0.4);
    }
    
    .control-btn.warning {
      background: linear-gradient(135deg, #ffd600 0%, #ff9800 100%);
      color: #1a1a1a;
      box-shadow: 0 3px 15px rgba(255,214,0,0.3);
    }
    
    .control-btn.warning:hover {
      background: linear-gradient(135deg, #ff9800 0%, #ffd600 100%);
      box-shadow: 0 5px 20px rgba(255,214,0,0.4);
    }
    
    .control-btn.danger {
      background: linear-gradient(135deg, #f44336 0%, #e53935 100%);
      box-shadow: 0 3px 15px rgba(244,67,54,0.3);
    }
    
    .control-btn.danger:hover {
      background: linear-gradient(135deg, #e53935 0%, #f44336 100%);
      box-shadow: 0 5px 20px rgba(244,67,54,0.4);
    }
    
    #langsel {
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      color: #fff;
      border-radius: 8px;
      border: 1px solid rgba(124,77,255,0.3);
      font-size: 1em;
      padding: 8px 12px;
      outline: none;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    #langsel:hover {
      border-color: rgba(124,77,255,0.6);
      box-shadow: 0 0 10px rgba(124,77,255,0.3);
    }
    
    #metrics { 
      font-size: 0.9em; 
      margin: 20px 0; 
      color: #b3e5fc; 
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      border-radius: 12px; 
      padding: 15px 20px;
      border: 1px solid rgba(124,77,255,0.2);
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .metric-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 8px 0;
      padding: 5px 0;
      border-bottom: 1px solid rgba(124,77,255,0.1);
    }
    
    .metric-label {
      font-weight: bold;
      color: #90caf9;
    }
    
    .metric-value {
      color: #43e684;
      font-family: monospace;
    }
    
    #form { 
      display: flex; 
      gap: 10px; 
      margin-bottom: 20px;
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      padding: 15px;
      border-radius: 12px;
      border: 1px solid rgba(124,77,255,0.2);
    }
    
    #input { 
      flex: 1; 
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      color: #fff; 
      border: 1px solid rgba(124,77,255,0.3);
      border-radius: 8px; 
      padding: 12px 16px; 
      font-size: 1em; 
      outline: none; 
      transition: all 0.3s ease;
      box-shadow: inset 0 2px 5px rgba(0,0,0,0.3);
    }
    
    #input:focus {
      border-color: #7c4dff;
      box-shadow: 0 0 15px rgba(124,77,255,0.4), inset 0 2px 5px rgba(0,0,0,0.3);
    }
    
    #form button { 
      background: linear-gradient(135deg, #7c4dff 0%, #9c27b0 100%);
      color: #fff; 
      border: none; 
      border-radius: 8px; 
      padding: 12px 24px; 
      font-size: 1em; 
      cursor: pointer; 
      transition: all 0.3s ease;
      box-shadow: 0 3px 15px rgba(124,77,255,0.3);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    #form button:hover { 
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124,77,255,0.4);
      background: linear-gradient(135deg, #9c27b0 0%, #7c4dff 100%);
    }
    
    .console-section {
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
      border-radius: 12px;
      padding: 20px;
      margin: 20px 0;
      border: 1px solid rgba(124,77,255,0.2);
      box-shadow: 0 5px 20px rgba(0,0,0,0.3);
    }
    
    #liveConsole {
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      color: #ffd600; 
      font-family: 'Consolas', 'Monaco', monospace; 
      font-size: 0.95em;
      min-height: 120px; 
      max-height: 300px; 
      overflow: auto; 
      border-radius: 8px;
      padding: 15px; 
      margin: 15px 0;
      box-shadow: inset 0 2px 10px rgba(0,0,0,0.5);
      border: 1px solid rgba(255,214,0,0.2);
    }
    
    #consoleForm { 
      display: flex;
      gap: 10px;
      margin: 10px 0;
    }
    
    #consoleInput { 
      flex: 1;
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      color: #fff;
      border-radius: 6px;
      border: 1px solid rgba(124,77,255,0.3);
      padding: 8px 12px;
      outline: none;
      transition: all 0.3s ease;
    }
    
    #consoleInput:focus {
      border-color: #ffd600;
      box-shadow: 0 0 10px rgba(255,214,0,0.3);
    }
    
    #consoleForm button { 
      background: linear-gradient(135deg, #ffd600 0%, #ff9800 100%);
      color: #1a1a1a;
      border-radius: 6px;
      border: none;
      padding: 8px 16px;
      font-size: 0.95em;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.3s ease;
    }
    
    #consoleForm button:hover { 
      transform: translateY(-1px);
      box-shadow: 0 3px 10px rgba(255,214,0,0.4);
    }
    
    .modal-overlay {
      position: fixed;
      left: 0;
      top: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.8);
      backdrop-filter: blur(5px);
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease;
    }
    
    .modal-content {
      background: linear-gradient(135deg, #1e2436 0%, #2a3245 100%);
      padding: 30px 40px;
      border-radius: 20px;
      max-width: 90vw;
      max-height: 90vh;
      overflow: auto;
      box-shadow: 0 20px 80px rgba(0,0,0,0.6);
      border: 1px solid rgba(124,77,255,0.3);
    }
    
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.9); }
      to { opacity: 1; transform: scale(1); }
    }
    
    .progress-bar {
      width: 100%;
      height: 6px;
      background: rgba(124,77,255,0.2);
      border-radius: 3px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #7c4dff 0%, #b388ff 100%);
      border-radius: 3px;
      transition: width 0.3s ease;
      animation: progressPulse 2s infinite;
    }
    
    @keyframes progressPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    
    #copyright {
      text-align: center;
      color: #7c4dff;
      font-size: 0.9em;
      margin-top: 40px;
      padding: 20px;
      background: linear-gradient(135deg, #0a0e1a 0%, #1a1f2e 100%);
      border-radius: 15px;
      border: 1px solid rgba(124,77,255,0.2);
      letter-spacing: 1px;
      font-weight: 500;
    }
    
    .floating-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    
    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #7c4dff;
      border-radius: 50%;
      animation: float 8s infinite linear;
    }
    
    @keyframes float {
      0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-10vh) rotate(360deg); opacity: 0; }
    }
    
    .neural-network {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0.1;
    }
    
    .neural-node {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #b388ff;
      border-radius: 50%;
      animation: neuralPulse 3s infinite ease-in-out;
    }
    
    @keyframes neuralPulse {
      0%, 100% { transform: scale(1); opacity: 0.3; }
      50% { transform: scale(1.5); opacity: 0.7; }
    }
    
    .context-display {
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      border-radius: 8px;
      padding: 10px 15px;
      margin: 10px 0;
      border: 1px solid rgba(124,77,255,0.2);
      font-size: 0.9em;
      color: #b3e5fc;
    }
    
    .quantum-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 8px;
      animation: quantumFlicker 1.5s infinite;
    }
    
    @keyframes quantumFlicker {
      0%, 100% { background: #7c4dff; box-shadow: 0 0 5px #7c4dff; }
      33% { background: #43e684; box-shadow: 0 0 5px #43e684; }
      66% { background: #ffd600; box-shadow: 0 0 5px #ffd600; }
    }
    
    .advanced-metrics {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin: 20px 0;
    }
    
    .metric-card {
      background: linear-gradient(135deg, #1a2332 0%, #242d3f 100%);
      border-radius: 10px;
      padding: 15px;
      border: 1px solid rgba(124,77,255,0.2);
      text-align: center;
      transition: all 0.3s ease;
    }
    
    .metric-card:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(124,77,255,0.3);
    }
    
    .metric-card .value {
      font-size: 1.8em;
      font-weight: bold;
      color: #43e684;
      margin-bottom: 5px;
    }
    
    .metric-card .label {
      font-size: 0.9em;
      color: #b3e5fc;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    @media (max-width: 768px) {
      #interface {
        margin: 1vh 5px;
        padding: 20px 15px;
      }
      
      .control-panel {
        grid-template-columns: 1fr;
      }
      
      .advanced-controls {
        justify-content: center;
      }
      
      .control-btn {
        font-size: 0.8em;
        padding: 6px 12px;
      }
    }
  </style>
</head>
<body>
  <div class="floating-particles" id="particles"></div>
  
  <div id="interface">
    <div class="neural-network" id="neuralNetwork"></div>
    
    <div class="header-panel">
      <div class="logo">
        <span class="quantum-indicator"></span>
        CAR UltraViolet v2025
      </div>
      <div class="system-status">
        <div class="status-indicator"></div>
        <span>Système Actif</span>
      </div>
    </div>
    
    <div class="quantum-vortex-container">
      <canvas id="vortex" width="550" height="550"></canvas>
    </div>
    
    <div class="context-display" id="context"></div>
    
    <div class="control-panel">
      <div class="panel-section">
        <div class="panel-title">Contrôles Cognitifs</div>
        <div class="advanced-controls">
          <select id="langsel">
            <option value="fr">Français</option>
            <option value="en">English</option>
            <option value="es">Español</option>
            <option value="de">Deutsch</option>
            <option value="it">Italiano</option>
            <option value="pt">Português</option>
            <option value="ru">Русский</option>
            <option value="ja">日本語</option>
            <option value="zh">中文</option>
          </select>
          <button id="mutateBtn" class="control-btn warning" title="Déclencher une mutation cognitive quantique">
            Mutation Quantique
          </button>
          <button id="wikiBtn" class="control-btn secondary" title="Accéder au wiki hybride">
            Wiki Hybride
          </button>
          <button id="logBtn" class="control-btn" title="Consulter les logs système">
            Journal Système
          </button>
          <button id="resetBtn" class="control-btn danger" title="Réinitialiser le système">
            Reset Total
          </button>
        </div>
      </div>
      
      <div class="panel-section">
        <div class="panel-title">Modules Avancés</div>
        <div class="advanced-controls">
          <button id="neuralBtn" class="control-btn" title="Analyse neuronale">
            Réseau Neural
          </button>
          <button id="quantumBtn" class="control-btn" title="Simulation quantique">
            Quantum Sim
          </button>
          <button id="aiBtn" class="control-btn" title="IA Générative">
            IA Générative
          </button>
          <button id="exportBtn" class="control-btn secondary" title="Export système">
            Export Data
          </button>
        </div>
      </div>
    </div>
    
    <div id="chat"></div>
    
    <form id="form" autocomplete="off">
      <input id="input" autocomplete="off" placeholder="Entrez votre requête cognitive..." autofocus/>
      <button type="submit">Traiter</button>
    </form>
    
    <div class="advanced-metrics" id="advancedMetrics"></div>
    
    <div class="console-section">
      <div class="panel-title">Console JavaScript Avancée</div>
      <div class="advanced-controls">
        <button onclick="clearLiveConsole()" class="control-btn">Vider Console</button>
        <button onclick="exportLiveConsole()" class="control-btn secondary">Export Console</button>
        <button onclick="loadModule()" class="control-btn warning">Charger Module</button>
        <button onclick="systemDiagnostic()" class="control-btn">Diagnostic</button>
      </div>
      <div id="liveConsole">Console JavaScript Avancée initialisée...</div>
      <form id="consoleForm">
        <input id="consoleInput" placeholder="Code JavaScript..." />
        <button type="submit">Exécuter</button>
      </form>
    </div>
    
    <div id="metrics"></div>
  </div>
  
  <footer id="copyright">
    © William Michaud (WM) 2025 - WM AI TECHNOLOGIES INC.<br>
    Système Cognitif Quantique Avancé - Version Professionnelle
  </footer>

  <script>
    // ====== SYSTÈME COGNITIF QUANTIQUE AVANCÉ v2025 ======
    
    // Configuration système
    const SYSTEM_CONFIG = {
      version: '2025.1.0',
      maxMemory: 10000,
      maxLogs: 1000,
      quantumDimensions: 12,
      neuralLayers: 8,
      cognitiveThreshold: 0.7,
      mutationRate: 0.15,
      adaptiveMode: true
    };
    
    // ====== STOCKAGE AVANCÉ ======
    class AdvancedStorage {
      constructor() {
        this.prefix = 'car_uv_2025_';
        this.compression = true;
        this.encryption = false; // Désactivé pour la demo
      }
      
      set(key, data) {
        try {
          let serialized = JSON.stringify(data);
          if (this.compression && serialized.length > 1000) {
            // Simulation de compression
            serialized = this.compress(serialized);
          }
          localStorage.setItem(this.prefix + key, serialized);
          return true;
        } catch (e) {
          console.error('Storage error:', e);
          return false;
        }
      }
      
      get(key, defaultValue = null) {
        try {
          let data = localStorage.getItem(this.prefix + key);
          if (!data) return defaultValue;
          
          if (this.compression && data.startsWith('COMP:')) {
            data = this.decompress(data);
          }
          
          return JSON.parse(data);
        } catch (e) {
          console.error('Retrieval error:', e);
          return defaultValue;
        }
      }
      
      compress(data) {
        // Simulation de compression simple
        return 'COMP:' + btoa(data);
      }
      
      decompress(data) {
        return atob(data.substring(5));
      }
      
      clear() {
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith(this.prefix)) {
            localStorage.removeItem(key);
          }
        });
      }
      
      export() {
        const data = {};
        Object.keys(localStorage).forEach(key => {
          if (key.startsWith(this.prefix)) {
            data[key] = localStorage.getItem(key);
          }
        });
        return data;
      }
    }
    
    const storage = new AdvancedStorage();
    
    // ====== EMBEDDING VECTORIEL AVANCÉ ======
    class AdvancedEmbedding {
      constructor(dimensions = 12) {
        this.dimensions = dimensions;
        this.cache = new Map();
        this.maxCache = 1000;
      }
      
      embed(text) {
        if (this.cache.has(text)) {
          return this.cache.get(text);
        }
        
        const vector = new Array(this.dimensions).fill(0);
        const words = text.toLowerCase().split(/\s+/);
        
        // Analyse contextuelle
        for (let i = 0; i < words.length; i++) {
          const word = words[i];
          const context = words.slice(Math.max(0, i-2), i+3);
          
          for (let j = 0; j < word.length; j++) {
            const char = word.charCodeAt(j);
            const pos = (j + i * word.length) % this.dimensions;
            
            // Facteurs contextuels
            const contextFactor = context.length / 5;
            const positionFactor = (i + 1) / words.length;
            const lengthFactor = word.length / 20;
            
            vector[pos] += (char % 17 - 8) * contextFactor * positionFactor * lengthFactor;
          }
        }
        
        // Normalisation
        const norm = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        const normalized = vector.map(val => val / (norm || 1));
        
        // Cache management
        if (this.cache.size >= this.maxCache) {
          const firstKey = this.cache.keys().next().value;
          this.cache.delete(firstKey);
        }
        
        this.cache.set(text, normalized);
        return normalized;
      }
      
      similarity(vec1, vec2) {
        if (vec1.length !== vec2.length) return 0;
        
        let dot = 0, norm1 = 0, norm2 = 0;
        for (let i = 0; i < vec1.length; i++) {
          dot += vec1[i] * vec2[i];
          norm1 += vec1[i] * vec1[i];
          norm2 += vec2[i] * vec2[i];
        }
        
        return dot / (Math.sqrt(norm1) * Math.sqrt(norm2) || 1);
      }
      
      findSimilar(targetVector, corpus, limit = 5) {
        const similarities = corpus.map((item, index) => ({
          index,
          similarity: this.similarity(targetVector, item.vector),
          content: item.content
        }));
        
        return similarities
          .sort((a, b) => b.similarity - a.similarity)
          .slice(0, limit);
      }
    }
    
    const embedding = new AdvancedEmbedding(SYSTEM_CONFIG.quantumDimensions);
    
    // ====== CLASSE NEURONE QUANTIQUE ======
    class QuantumNeuron {
      constructor(dimensions = 12) {
        this.dimensions = dimensions;
        this.state = new Array(dimensions).fill(0);
        this.weights = new Array(dimensions).fill(0).map(() => Math.random() * 2 - 1);
        this.bias = Math.random() * 2 - 1;
        this.activation = 'tanh';
        this.learning_rate = 0.01;
        this.momentum = new Array(dimensions).fill(0);
        this.momentum_factor = 0.9;
      }
      
      activate(inputs) {
        if (inputs.length !== this.dimensions) {
          throw new Error('Input dimension mismatch');
        }
        
        let sum = this.bias;
        for (let i = 0; i < this.dimensions; i++) {
          sum += inputs[i] * this.weights[i];
        }
        
        // Fonction d'activation
        switch (this.activation) {
          case 'tanh':
            return Math.tanh(sum);
          case 'sigmoid':
            return 1 / (1 + Math.exp(-sum));
          case 'relu':
            return Math.max(0, sum);
          default:
            return sum;
        }
      }
      
      learn(inputs, target, output) {
        const error = target - output;
        const delta = error * this.derivative(output);
        
        // Mise à jour des poids avec momentum
        for (let i = 0; i < this.dimensions; i++) {
          const gradient = delta * inputs[i];
          this.momentum[i] = this.momentum_factor * this.momentum[i] + this.learning_rate * gradient;
          this.weights[i] += this.momentum[i];
        }
        
        this.bias += this.learning_rate * delta;
      }
      
      derivative(output) {
        switch (this.activation) {
          case 'tanh':
            return 1 - output * output;
          case 'sigmoid':
            return output * (1 - output);
          case 'relu':
            return output > 0 ? 1 : 0;
          default:
            return 1;
        }
      }
      
      quantumFluctuation() {
        // Fluctuation quantique simulée
        const fluctuation = (Math.random() - 0.5) * 0.01;
        this.bias += fluctuation;
        
        for (let i = 0; i < this.dimensions; i++) {
          this.weights[i] += (Math.random() - 0.5) * 0.005;
        }
      }
    }
    
    // ====== RÉSEAU NEURONAL QUANTIQUE ======
    class QuantumNeuralNetwork {
      constructor(layers = [12, 8, 6, 4, 2]) {
        this.layers = layers;
        this.neurons = [];
        this.outputs = [];
        
        // Initialisation des couches
        for (let i = 1; i < layers.length; i++) {
          const layer = [];
          for (let j = 0; j < layers[i]; j++) {
            layer.push(new QuantumNeuron(layers[i-1]));
          }
          this.neurons.push(layer);
        }
        
        this.training_data = [];
        this.performance_history = [];
      }
      
      forward(inputs) {
        let current_inputs = inputs;
        this.outputs = [current_inputs];
        
        for (let layer of this.neurons) {
          const layer_outputs = [];
          for (let neuron of layer) {
            layer_outputs.push(neuron.activate(current_inputs));
          }
          current_inputs = layer_outputs;
          this.outputs.push(current_inputs);
        }
        
        return current_inputs;
      }
      
      backward(inputs, targets) {
        const outputs = this.forward(inputs);
        const errors = [];
        
        // Calcul des erreurs
        for (let i = 0; i < targets.length; i++) {
          errors.push(targets[i] - outputs[i]);
        }
        
        // Rétropropagation
        for (let i = this.neurons.length - 1; i >= 0; i--) {
          const layer = this.neurons[i];
          const layer_inputs = this.outputs[i];
          
          for (let j = 0; j < layer.length; j++) {
            const neuron = layer[j];
            const target = i === this.neurons.length - 1 ? targets[j] : 0;
            const output = this.outputs[i + 1][j];
            
            neuron.learn(layer_inputs, target, output);
          }
        }
        
        return errors;
      }
      
      train(training_data, epochs = 100) {
        this.training_data = training_data;
        
        for (let epoch = 0; epoch < epochs; epoch++) {
          let total_error = 0;
          
          for (let data of training_data) {
            const errors = this.backward(data.input, data.output);
            total_error += errors.reduce((sum, error) => sum + error * error, 0);
          }
          
          // Fluctuation quantique périodique
          if (epoch % 10 === 0) {
            this.applyQuantumFluctuation();
          }
          
          this.performance_history.push(total_error / training_data.length);
        }
      }
      
      applyQuantumFluctuation() {
        for (let layer of this.neurons) {
          for (let neuron of layer) {
            neuron.quantumFluctuation();
          }
        }
      }
      
      predict(inputs) {
        return this.forward(inputs);
      }
      
      getPerformance() {
        return {
          latest_error: this.performance_history[this.performance_history.length - 1] || 0,
          average_error: this.performance_history.reduce((sum, error) => sum + error, 0) / this.performance_history.length || 0,
          convergence: this.performance_history.length > 10 ? 
            this.performance_history.slice(-10).reduce((sum, error) => sum + error, 0) / 10 : 0
        };
      }
    }
    
    // ====== SYSTÈME COGNITIF QUANTIQUE PRINCIPAL ======
    class QuantumCognitiveSystem {
      constructor() {
        this.dimensions = SYSTEM_CONFIG.quantumDimensions;
        this.layers = [12, 8, 6, 4, 2, 4, 6, 8]; // Architecture symétrique
        this.state = new Array(this.layers.length).fill(0).map((_, i) => 
          new Array(this.layers[i]).fill(0)
        );
        
        this.neural_network = new QuantumNeuralNetwork();
        this.memory = [];
        this.semantics = new Map();
        this.concepts = new Map();
        this.associations = new Map();
        this.emotional_state = {
          valence: 0,
          arousal: 0,
          dominance: 0
        };
        
        this.core_state = 0;
        this.subjectivity = 0;
        this.consciousness_level = 0;
        this.attention_focus = [];
        
        this.mutation_history = [];
        this.learning_rate = 0.1;
        this.adaptation_rate = 0.05;
        
        this.time_step = 0;
        this.cycle_duration = 1000; // ms
        
        this.initializeQuantumState();
      }
      
      initializeQuantumState() {
        // Initialisation de l'état quantique
        for (let i = 0; i < this.layers.length; i++) {
          for (let j = 0; j < this.layers[i]; j++) {
            this.state[i][j] = (Math.random() - 0.5) * 0.1;
          }
        }
        
        // Patterns initiaux
        this.injectPattern('awareness', [0.8, 0.3, 0.6, 0.2]);
        this.injectPattern('curiosity', [0.4, 0.9, 0.1, 0.7]);
        this.injectPattern('learning', [0.6, 0.2, 0.8, 0.5]);
      }
      
      injectPattern(concept, pattern) {
        const layer = Math.floor(this.layers.length / 2);
        const embedding_vector = embedding.embed(concept);
        
        for (let i = 0; i < Math.min(pattern.length, this.layers[layer]); i++) {
          this.state[layer][i] = pattern[i];
        }
        
        this.semantics.set(concept, embedding_vector);
        this.concepts.set(concept, {
          activation: pattern.reduce((sum, val) => sum + val, 0) / pattern.length,
          frequency: 1,
          last_accessed: Date.now()
        });
      }
      
      propagate() {
        const new_state = this.state.map(layer => [...layer]);
        
        // Propagation inter-couches
        for (let i = 0; i < this.layers.length; i++) {
          for (let j = 0; j < this.layers[i]; j++) {
            let influence = 0;
            
            // Influence des couches adjacentes
            if (i > 0) {
              const prev_layer = this.state[i-1];
              const prev_index = Math.floor(j * prev_layer.length / this.layers[i]);
              influence += prev_layer[prev_index] * 0.4;
            }
            
            if (i < this.layers.length - 1) {
              const next_layer = this.state[i+1];
              const next_index = Math.floor(j * next_layer.length / this.layers[i]);
              influence += next_layer[next_index] * 0.3;
            }
            
            // Auto-influence
            influence += this.state[i][j] * 0.2;
            
            // Bruit quantique
            influence += (Math.random() - 0.5) * 0.05;
            
            // Fonction d'activation
            new_state[i][j] = Math.tanh(influence);
            
            // Seuil de conscience
            if (Math.abs(new_state[i][j]) > SYSTEM_CONFIG.cognitiveThreshold) {
              this.consciousness_level += 0.01;
            }
          }
        }
        
        this.state = new_state;
        this.updateDerivedStates();
        this.time_step++;
      }
      
      updateDerivedStates() {
        // Calcul de l'état central
        const center_layer = Math.floor(this.layers.length / 2);
        this.core_state = this.state[center_layer].reduce((sum, val) => sum + val, 0) / this.layers[center_layer];
        
        // Subjectivité
        const total_activation = this.state.flat().reduce((sum, val) => sum + Math.abs(val), 0);
        const total_neurons = this.state.flat().length;
        this.subjectivity = total_activation / total_neurons;
        
        // Niveau de conscience
        this.consciousness_level = Math.tanh(this.consciousness_level);
        
        // État émotionnel
        this.emotional_state.valence = this.core_state;
        this.emotional_state.arousal = this.subjectivity;
        this.emotional_state.dominance = this.consciousness_level;
        
        // Mémorisation sélective
        if (this.subjectivity > 0.5) {
          this.memory.push({
            timestamp: Date.now(),
            state: this.getStateSnapshot(),
            subjectivity: this.subjectivity,
            consciousness: this.consciousness_level
          });
          
          if (this.memory.length > SYSTEM_CONFIG.maxMemory) {
            this.memory.shift();
          }
        }
      }
      
      getStateSnapshot() {
        return {
          core: this.core_state,
          subjectivity: this.subjectivity,
          consciousness: this.consciousness_level,
          emotional: {...this.emotional_state},
          active_concepts: Array.from(this.concepts.keys()).slice(0, 5)
        };
      }
      
      activate(layer_index, neuron_index, strength = 1.0, concept = null) {
        if (layer_index >= 0 && layer_index < this.layers.length &&
            neuron_index >= 0 && neuron_index < this.layers[layer_index]) {
          
          this.state[layer_index][neuron_index] = Math.tanh(strength);
          
          if (concept) {
            this.injectPattern(concept, [strength]);
            this.updateConceptActivation(concept, strength);
          }
        }
      }
      
      updateConceptActivation(concept, strength) {
        if (this.concepts.has(concept)) {
          const concept_data = this.concepts.get(concept);
          concept_data.activation = (concept_data.activation + strength) / 2;
          concept_data.frequency++;
          concept_data.last_accessed = Date.now();
        }
      }
      
      mutate(intensity = 0.1) {
        const mutation_type = Math.random();
        const mutation_data = {
          timestamp: Date.now(),
          type: '',
          intensity: intensity,
          affected_layers: []
        };
        
        if (mutation_type < 0.3) {
          // Mutation de structure
          mutation_data.type = 'structural';
          for (let i = 0; i < this.layers.length; i++) {
            if (Math.random() < intensity) {
              for (let j = 0; j < this.layers[i]; j++) {
                if (Math.random() < 0.1) {
                  this.state[i][j] += (Math.random() - 0.5) * intensity;
                }
              }
              mutation_data.affected_layers.push(i);
            }
          }
        } else if (mutation_type < 0.6) {
          // Mutation sémantique
          mutation_data.type = 'semantic';
          const concepts = Array.from(this.concepts.keys());
          if (concepts.length > 0) {
            const concept = concepts[Math.floor(Math.random() * concepts.length)];
            const new_embedding = embedding.embed(concept + '_mutated');
            this.semantics.set(concept + '_variant', new_embedding);
          }
        } else {
          // Mutation adaptative
          mutation_data.type = 'adaptive';
          this.learning_rate *= (1 + (Math.random() - 0.5) * intensity);
          this.adaptation_rate *= (1 + (Math.random() - 0.5) * intensity);
        }
        
        this.mutation_history.push(mutation_data);
        if (this.mutation_history.length > 100) {
          this.mutation_history.shift();
        }
        
        // Propagation forcée après mutation
        for (let i = 0; i < 5; i++) {
          this.propagate();
        }
        
        return mutation_data;
      }
      
      reset() {
        this.state = new Array(this.layers.length).fill(0).map((_, i) => 
          new Array(this.layers[i]).fill(0)
        );
        this.memory = [];
        this.semantics.clear();
        this.concepts.clear();
        this.associations.clear();
        this.mutation_history = [];
        this.core_state = 0;
        this.subjectivity = 0;
        this.consciousness_level = 0;
        this.time_step = 0;
        this.initializeQuantumState();
      }
      
      getMetrics() {
        return {
          core_state: this.core_state,
          subjectivity: this.subjectivity,
          consciousness: this.consciousness_level,
          memory_size: this.memory.length,
          concept_count: this.concepts.size,
          semantic_embeddings: this.semantics.size,
          mutations: this.mutation_history.length,
          time_steps: this.time_step,
          learning_rate: this.learning_rate,
          adaptation_rate: this.adaptation_rate,
          emotional_state: this.emotional_state,
          neural_performance: this.neural_network.getPerformance()
        };
      }
    }
    
    // ====== SYSTÈME WIKI HYBRIDE AVANCÉ ======
    class HybridWikiSystem {
      constructor() {
        this.articles = storage.get('wiki_articles', {});
        this.journal = storage.get('wiki_journal', []);
        this.cache = new Map();
        this.sync_queue = [];
        this.last_sync = storage.get('last_sync', 0);
        this.auto_sync_interval = 60000; // 1 minute
        
        this.initializeAutoSync();
      }
      
      initializeAutoSync() {
        setInterval(() => {
          this.processSyncQueue();
        }, this.auto_sync_interval);
      }
      
      async addArticle(title, content, metadata = {}) {
        const article = {
          title: title.trim(),
          content: content.trim(),
          metadata: {
            created: Date.now(),
            modified: Date.now(),
            version: 1,
            tags: [],
            category: 'general',
            ...metadata
          },
          embedding: embedding.embed(content),
          versions: [],
          links: this.extractLinks(content)
        };
        
        if (this.articles[title]) {
          article.versions = this.articles[title].versions || [];
          article.versions.push({
            content: this.articles[title].content,
            timestamp: this.articles[title].metadata.modified,
            version: this.articles[title].metadata.version
          });
          article.metadata.version = this.articles[title].metadata.version + 1;
        }
        
        this.articles[title] = article;
        this.logAction('add_article', title, metadata);
        this.save();
        
        // Mise à jour des associations
        this.updateAssociations(title, content);
        
        return article;
      }
      
      extractLinks(content) {
        const links = [];
        const linkRegex = /\[\[([^\]]+)\]\]/g;
        let match;
        
        while ((match = linkRegex.exec(content)) !== null) {
          links.push(match[1]);
        }
        
        return links;
      }
      
      updateAssociations(title, content) {
        const article_embedding = embedding.embed(content);
        const similarities = [];
        
        for (const [other_title, other_article] of Object.entries(this.articles)) {
          if (other_title !== title && other_article.embedding) {
            const similarity = embedding.similarity(article_embedding, other_article.embedding);
            if (similarity > 0.3) {
              similarities.push({
                title: other_title,
                similarity: similarity
              });
            }
          }
        }
        
        this.articles[title].associations = similarities
          .sort((a, b) => b.similarity - a.similarity)
          .slice(0, 5);
      }
      
      async fetchWikipedia(title, lang = 'fr') {
        const cache_key = `wiki_${lang}_${title}`;
        
        if (this.cache.has(cache_key)) {
          return this.cache.get(cache_key);
        }
        
        try {
          const url = `https://${lang}.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(title)}`;
          const response = await fetch(url);
          
          if (!response.ok) {
            return null;
          }
          
          const data = await response.json();
          const result = {
            title: data.title,
            extract: data.extract,
            url: data.content_urls?.desktop?.page,
            thumbnail: data.thumbnail?.source,
            lang: lang
          };
          
          this.cache.set(cache_key, result);
          return result;
        } catch (error) {
          console.error('Wikipedia fetch error:', error);
          return null;
        }
      }
      
      async getHybridArticle(title, lang = 'fr') {
        const local = this.articles[title];
        const wikipedia = await this.fetchWikipedia(title, lang);
        
        let fusion = null;
        if (local && wikipedia) {
          fusion = this.fuseArticles(local, wikipedia);
        }
        
        return {
          local: local,
          wikipedia: wikipedia,
          fusion: fusion,
          recommendations: this.getRecommendations(title)
        };
      }
      
      fuseArticles(local, wikipedia) {
        const local_sentences = local.content.split(/[.!?]+/);
        const wiki_sentences = wikipedia.extract.split(/[.!?]+/);
        
        const fused_content = [];
        const used_wiki_sentences = new Set();
        
        // Ajouter le contenu local
        fused_content.push('=== Contenu Local ===');
        fused_content.push(local.content);
        
        // Ajouter le contenu Wikipedia complémentaire
        fused_content.push('\n=== Informations Wikipedia ===');
        
        for (const wiki_sentence of wiki_sentences) {
          const wiki_clean = wiki_sentence.trim();
          if (wiki_clean.length > 10) {
            let is_duplicate = false;
            
            for (const local_sentence of local_sentences) {
              const similarity = embedding.similarity(
                embedding.embed(wiki_clean),
                embedding.embed(local_sentence.trim())
              );
              
              if (similarity > 0.7) {
                is_duplicate = true;
                break;
              }
            }
            
            if (!is_duplicate) {
              fused_content.push(wiki_clean + '.');
            }
          }
        }
        
        return fused_content.join('\n');
      }
      
      getRecommendations(title) {
        const recommendations = [];
        
        if (this.articles[title] && this.articles[title].associations) {
          recommendations.push(...this.articles[title].associations.map(assoc => ({
            title: assoc.title,
            reason: 'Similarité sémantique',
            score: assoc.similarity
          })));
        }
        
        // Recommandations basées sur les liens
        if (this.articles[title] && this.articles[title].links) {
          for (const link of this.articles[title].links) {
            if (this.articles[link]) {
              recommendations.push({
                title: link,
                reason: 'Lien direct',
                score: 0.9
              });
            }
          }
        }
        
        return recommendations.sort((a, b) => b.score - a.score).slice(0, 5);
      }
      
      search(query, options = {}) {
        const {
          semantic = true,
          exact = true,
          limit = 10,
          threshold = 0.3
        } = options;
        
        const results = [];
        const query_embedding = semantic ? embedding.embed(query) : null;
        
        for (const [title, article] of Object.entries(this.articles)) {
          let score = 0;
          const matches = [];
          
          // Recherche exacte
          if (exact) {
            const title_match = title.toLowerCase().includes(query.toLowerCase());
            const content_match = article.content.toLowerCase().includes(query.toLowerCase());
            
            if (title_match) {
              score += 2;
              matches.push('title');
            }
            if (content_match) {
              score += 1;
              matches.push('content');
            }
          }
          
          // Recherche sémantique
          if (semantic && article.embedding) {
            const similarity = embedding.similarity(query_embedding, article.embedding);
            if (similarity > threshold) {
              score += similarity * 3;
              matches.push('semantic');
            }
          }
          
          if (score > 0) {
            results.push({
              title: title,
              article: article,
              score: score,
              matches: matches
            });
          }
        }
        
        return results
          .sort((a, b) => b.score - a.score)
          .slice(0, limit);
      }
      
      logAction(action, title, metadata = {}) {
        const entry = {
          timestamp: Date.now(),
          action: action,
          title: title,
          metadata: metadata
        };
        
        this.journal.push(entry);
        
        if (this.journal.length > SYSTEM_CONFIG.maxLogs) {
          this.journal.shift();
        }
      }
      
      save() {
        storage.set('wiki_articles', this.articles);
        storage.set('wiki_journal', this.journal);
        storage.set('last_sync', Date.now());
      }
      
      processSyncQueue() {
        // Traitement de la queue de synchronisation
        if (this.sync_queue.length > 0) {
          console.log(`Processing ${this.sync_queue.length} sync operations...`);
          this.sync_queue = [];
        }
      }
      
      export() {
        return {
          articles: this.articles,
          journal: this.journal,
          metadata: {
            export_timestamp: Date.now(),
            article_count: Object.keys(this.articles).length,
            journal_entries: this.journal.length
          }
        };
      }
      
      import(data) {
        if (data.articles) {
          this.articles = { ...this.articles, ...data.articles };
        }
        if (data.journal) {
          this.journal.push(...data.journal);
        }
        this.save();
      }
    }
    
    // ====== SYSTÈME DE LOGGING AVANCÉ ======
    class AdvancedLogger {
      constructor() {
        this.logs = storage.get('system_logs', []);
        this.console_logs = [];
        this.performance_logs = [];
        this.error_logs = [];
        this.max_logs = SYSTEM_CONFIG.maxLogs;
        
        this.initializeErrorHandling();
      }
      
      initializeErrorHandling() {
        window.addEventListener('error', (e) => {
          this.error(e.message, {
            filename: e.filename,
            lineno: e.lineno,
            colno: e.colno,
            stack: e.error?.stack
          });
        });
        
        window.addEventListener('unhandledrejection', (e) => {
          this.error('Unhandled Promise Rejection: ' + e.reason, {
            promise: true
          });
        });
      }
      
      log(level, message, metadata = {}) {
        const entry = {
          timestamp: Date.now(),
          level: level,
          message: message,
          metadata: metadata,
          session: this.getSessionId()
        };
        
        this.logs.push(entry);
        
        // Dispatch vers les logs spécialisés
        switch (level) {
          case 'error':
            this.error_logs.push(entry);
            break;
          case 'performance':
            this.performance_logs.push(entry);
            break;
          case 'console':
            this.console_logs.push(entry);
            break;
        }
        
        // Nettoyage
        if (this.logs.length > this.max_logs) {
          this.logs.shift();
        }
        
        // Sauvegarde périodique
        if (this.logs.length % 10 === 0) {
          this.save();
        }
        
        // Affichage console
        this.displayInConsole(entry);
      }
      
      info(message, metadata = {}) {
        this.log('info', message, metadata);
      }
      
      warn(message, metadata = {}) {
        this.log('warn', message, metadata);
      }
      
      error(message, metadata = {}) {
        this.log('error', message, metadata);
      }
      
      debug(message, metadata = {}) {
        this.log('debug', message, metadata);
      }
      
      performance(message, metadata = {}) {
        this.log('performance', message, metadata);
      }
      
      displayInConsole(entry) {
        const console_element = document.getElementById('liveConsole');
        if (!console_element) return;
        
        const colors = {
          info: '#43e684',
          warn: '#ffd600',
          error: '#ff5252',
          debug: '#b3e5fc',
          performance: '#9c27b0'
        };
        
        const color = colors[entry.level] || '#ffffff';
        const time = new Date(entry.timestamp).toLocaleTimeString();
        
        const log_element = document.createElement('div');
        log_element.style.color = color;
        log_element.style.marginBottom = '3px';
        log_element.innerHTML = `<strong>[${time}] [${entry.level.toUpperCase()}]</strong> ${entry.message}`;
        
        console_element.appendChild(log_element);
        console_element.scrollTop = console_element.scrollHeight;
        
        // Limite d'affichage
        const max_display = 100;
        if (console_element.children.length > max_display) {
          console_element.removeChild(console_element.firstChild);
        }
      }
      
      getSessionId() {
        if (!this.session_id) {
          this.session_id = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }
        return this.session_id;
      }
      
      save() {
        storage.set('system_logs', this.logs);
      }
      
      export() {
        return {
          logs: this.logs,
          console_logs: this.console_logs,
          performance_logs: this.performance_logs,
          error_logs: this.error_logs,
          metadata: {
            session_id: this.session_id,
            export_timestamp: Date.now()
          }
        };
      }
      
      clear() {
        this.logs = [];
        this.console_logs = [];
        this.performance_logs = [];
        this.error_logs = [];
        this.save();
        
        const console_element = document.getElementById('liveConsole');
        if (console_element) {
          console_element.innerHTML = 'Console cleared...';
        }
      }
      
      getStats() {
        const levels = {};
        for (const log of this.logs) {
          levels[log.level] = (levels[log.level] || 0) + 1;
        }
        
        return {
          total_logs: this.logs.length,
          levels: levels,
          errors: this.error_logs.length,
          session_id: this.session_id,
          uptime: Date.now() - (this.logs[0]?.timestamp || Date.now())
        };
      }
    }
    
    // ====== INITIALISATION DU SYSTÈME ======
    const quantumSystem = new QuantumCognitiveSystem();
    const wikiSystem = new HybridWikiSystem();
    const logger = new AdvancedLogger();
    
    // Variables globales
    let chat_history = [];
    let current_language = 'fr';
    let system_running = true;
    let auto_mutation_active = true;
    
    // Éléments DOM
    const chat = document.getElementById('chat');
    const form = document.getElementById('form');
    const input = document.getElementById('input');
    const canvas = document.getElementById('vortex');
    const ctx = canvas.getContext('2d');
    const contextDiv = document.getElementById('context');
    const metricsDiv = document.getElementById('metrics');
    const advancedMetricsDiv = document.getElementById('advancedMetrics');
    const langSelect = document.getElementById('langsel');
    
    // ====== FONCTIONS UTILITAIRES ======
    function extractConcepts(text) {
      const words = text.toLowerCase().match(/\b\w{4,}\b/g) || [];
      const stopWords = ['this', 'that', 'with', 'have', 'will', 'from', 'they', 'been', 'were', 'said', 'each', 'which', 'their', 'time', 'would', 'there', 'could', 'other'];
      
      return [...new Set(words)]
        .filter(word => !stopWords.includes(word))
        .slice(0, 5);
    }
    
    function formatMessage(type, content, metadata = {}) {
      const timestamp = new Date().toLocaleTimeString();
      const classes = {
        user: 'user',
        bot: 'bot uv',
        system: 'introspection',
        mutation: 'mutation',
        wiki: 'wiki'
      };
      
      return `<div class="${classes[type] || 'bot'}">
        <span style="opacity: 0.7;">[${timestamp}]</span> ${content}
      </div>`;
    }
    
    function addToChat(type, content, metadata = {}) {
      const message = formatMessage(type, content, metadata);
      chat.innerHTML += message;
      chat.scrollTop = chat.scrollHeight;
      
      chat_history.push({
        timestamp: Date.now(),
        type: type,
        content: content,
        metadata: metadata
      });
      
      if (chat_history.length > 1000) {
        chat_history.shift();
      }
      
      logger.info(`Chat message: ${type}`, { content: content.substring(0, 100) });
    }
    
    // ====== FONCTIONS DE RENDU ======
    function drawQuantumVortex() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const time = Date.now() * 0.001;
      
      // Nœud central
      const coreEnergy = Math.abs(quantumSystem.core_state);
      const consciousnessRadius = 40 + coreEnergy * 30;
      
      // Effet de halo central
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, consciousnessRadius);
      gradient.addColorStop(0, `rgba(124, 77, 255, ${0.8 + coreEnergy * 0.2})`);
      gradient.addColorStop(0.5, `rgba(179, 136, 255, ${0.4 + coreEnergy * 0.3})`);
      gradient.addColorStop(1, 'rgba(124, 77, 255, 0)');
      
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Anneaux de conscience
      for (let ring = 0; ring < 5; ring++) {
        const radius = 60 + ring * 40;
        const opacity = 0.3 - ring * 0.05;
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius + Math.sin(time + ring) * 10, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(124, 77, 255, ${opacity})`;
        ctx.lineWidth = 2 + Math.sin(time * 2 + ring) * 1;
        ctx.stroke();
      }
      
      // Neurones quantiques
      quantumSystem.state.forEach((layer, layerIndex) => {
        const layerRadius = 80 + layerIndex * 35;
        const angleStep = (Math.PI * 2) / layer.length;
        
        layer.forEach((activation, neuronIndex) => {
          const angle = neuronIndex * angleStep + time * 0.5 + layerIndex * 0.2;
          const x = centerX + Math.cos(angle) * layerRadius;
          const y = centerY + Math.sin(angle) * layerRadius;
          
          // Connexions
          if (Math.abs(activation) > 0.1) {
            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(x, y);
            ctx.strokeStyle = `rgba(67, 230, 132, ${Math.abs(activation) * 0.6})`;
            ctx.lineWidth = Math.abs(activation) * 3;
            ctx.stroke();
          }
          
          // Neurone
          const neuronSize = 3 + Math.abs(activation) * 8;
          ctx.beginPath();
          ctx.arc(x, y, neuronSize, 0, Math.PI * 2);
          ctx.fillStyle = activation > 0 ? 
            `rgba(67, 230, 132, ${Math.abs(activation)})` : 
            `rgba(255, 82, 82, ${Math.abs(activation)})`;
          ctx.fill();
          
          // Halo du neurone
          if (Math.abs(activation) > 0.5) {
            ctx.beginPath();
            ctx.arc(x, y, neuronSize + 5, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 214, 0, ${Math.abs(activation) * 0.5})`;
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        });
      });
      
      // Indicateur de subjectivité
      const subjectivityAngle = quantumSystem.subjectivity * Math.PI * 2;
      const subjectivityRadius = 200;
      const subjectivityX = centerX + Math.cos(subjectivityAngle) * subjectivityRadius;
      const subjectivityY = centerY + Math.sin(subjectivityAngle) * subjectivityRadius;
      
      ctx.beginPath();
      ctx.arc(subjectivityX, subjectivityY, 8, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(213, 0, 249, ${quantumSystem.subjectivity})`;
      ctx.fill();
      
      // Particules quantiques
      for (let i = 0; i < 20; i++) {
        const particleAngle = (i / 20) * Math.PI * 2 + time * 2;
        const particleRadius = 150 + Math.sin(time + i) * 30;
        const particleX = centerX + Math.cos(particleAngle) * particleRadius;
        const particleY = centerY + Math.sin(particleAngle) * particleRadius;
        
        ctx.beginPath();
        ctx.arc(particleX, particleY, 1 + Math.sin(time * 3 + i) * 1, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(255, 214, 0, ${0.3 + Math.sin(time + i) * 0.3})`;
        ctx.fill();
      }
    }
    
    function updateMetrics() {
      const metrics = quantumSystem.getMetrics();
      const wiki_stats = {
        articles: Object.keys(wikiSystem.articles).length,
        journal_entries: wikiSystem.journal.length
      };
      const log_stats = logger.getStats();
      
      // Métriques principales
      metricsDiv.innerHTML = `
        <div class="metric-item">
          <span class="metric-label">État Central:</span>
          <span class="metric-value">${metrics.core_state.toFixed(3)}</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Subjectivité:</span>
          <span class="metric-value">${metrics.subjectivity.toFixed(3)}</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Conscience:</span>
          <span class="metric-value">${metrics.consciousness.toFixed(3)}</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Mémoire:</span>
          <span class="metric-value">${metrics.memory_size}</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Concepts:</span>
          <span class="metric-value">${metrics.concept_count}</span>
        </div>
        <div class="metric-item">
          <span class="metric-label">Embeddings:</span>
          <span class="metric-value">${metrics.semantic_embeddings}</span>
        </div>
      `;
      
      // Métriques avancées
      advancedMetricsDiv.innerHTML = `
        <div class="metric-card">
          <div class="value">${wiki_stats.articles}</div>
          <div class="label">Articles Wiki</div>
        </div>
        <div class="metric-card">
          <div class="value">${log_stats.total_logs}</div>
          <div class="label">Logs Système</div>
        </div>
        <div class="metric-card">
          <div class="value">${metrics.mutations}</div>
          <div class="label">Mutations</div>
        </div>
        <div class="metric-card">
          <div class="value">${metrics.time_steps}</div>
          <div class="label">Cycles</div>
        </div>
        <div class="metric-card">
          <div class="value">${(metrics.learning_rate * 100).toFixed(1)}%</div>
          <div class="label">Taux d'apprentissage</div>
        </div>
        <div class="metric-card">
          <div class="value">${(metrics.neural_performance.latest_error || 0).toFixed(3)}</div>
          <div class="label">Erreur Neuronale</div>
        </div>
      `;
    }
    
    function updateContext() {
      const now = new Date();
      const context = {
        time: now.toLocaleTimeString(),
        date: now.toLocaleDateString(),
        language: current_language,
        system_state: system_running ? 'Actif' : 'Suspendu',
        consciousness: quantumSystem.consciousness_level.toFixed(2)
      };
      
      contextDiv.innerHTML = `
        <strong>${context.date}</strong> ${context.time} | 
        <strong>Langue:</strong> ${context.language} | 
        <strong>Système:</strong> ${context.system_state} | 
        <strong>Conscience:</strong> ${context.consciousness}
      `;
    }
    
    // ====== GESTION DES ÉVÉNEMENTS ======
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const message = input.value.trim();
      if (!message) return;
      
      addToChat('user', message);
      input.value = '';
      
      try {
        await processUserMessage(message);
      } catch (error) {
        logger.error('Error processing message', { error: error.message });
        addToChat('system', 'Erreur lors du traitement du message: ' + error.message);
      }
    });
    
    async function processUserMessage(message) {
      const concepts = extractConcepts(message);
      
      // Injection dans le système quantique
      if (concepts.length > 0) {
        const primary_concept = concepts[0];
        const layer = Math.floor(quantumSystem.layers.length / 2);
        const neuron = Math.floor(Math.random() * quantumSystem.layers[layer]);
        
        quantumSystem.activate(layer, neuron, 0.8, primary_concept);
        
        // Propagation
        for (let i = 0; i < 3; i++) {
          quantumSystem.propagate();
        }
        
        logger.info('Concept activated', { concept: primary_concept, layer, neuron });
      }
      
      // Traitement des commandes spéciales
      if (message.toLowerCase().startsWith('wiki:')) {
        const title = message.substring(5).trim();
        await handleWikiCommand(title);
        return;
      }
      
      if (message.toLowerCase().startsWith('mutate:')) {
        const intensity = parseFloat(message.substring(7)) || 0.1;
        const mutation = quantumSystem.mutate(intensity);
        addToChat('mutation', `Mutation ${mutation.type} appliquée avec intensité ${intensity}`);
        return;
      }
      
      if (message.toLowerCase().startsWith('analyze:')) {
        const text = message.substring(8).trim();
        await performAnalysis(text);
        return;
      }
      
      // Traitement standard
      await generateResponse(message, concepts);
    }
    
    async function handleWikiCommand(title) {
      const hybrid_article = await wikiSystem.getHybridArticle(title, current_language);
      
      if (hybrid_article.local || hybrid_article.wikipedia) {
        let response = `<strong>Recherche Wiki: ${title}</strong><br>`;
        
        if (hybrid_article.local) {
          response += `<span class="wikisrc">Local:</span> ${hybrid_article.local.content.substring(0, 200)}...<br>`;
        }
        
        if (hybrid_article.wikipedia) {
          response += `<span class="wikisrc">Wikipedia:</span> ${hybrid_article.wikipedia.extract.substring(0, 200)}...<br>`;
        }
        
        if (hybrid_article.fusion) {
          response += `<span class="wiki">Fusion disponible</span><br>`;
        }
        
        if (hybrid_article.recommendations.length > 0) {
          response += `<strong>Recommandations:</strong> ${hybrid_article.recommendations.map(r => r.title).join(', ')}`;
        }
        
        addToChat('wiki', response);
        
        // Auto-ajout si Wikipedia trouvé mais pas de local
        if (hybrid_article.wikipedia && !hybrid_article.local) {
          await wikiSystem.addArticle(title, hybrid_article.wikipedia.extract, {
            source: 'wikipedia',
            language: current_language
          });
          addToChat('system', `Article "${title}" ajouté automatiquement depuis Wikipedia`);
        }
      } else {
        addToChat('wiki', `Aucun article trouvé pour "${title}"`);
      }
    }
    
    async function performAnalysis(text) {
      const text_embedding = embedding.embed(text);
      const concepts = extractConcepts(text);
      
      // Recherche d'articles similaires
      const search_results = wikiSystem.search(text, { semantic: true, limit: 3 });
      
      let analysis = `<strong>Analyse: "${text.substring(0, 50)}..."</strong><br>`;
      analysis += `<strong>Concepts extraits:</strong> ${concepts.join(', ')}<br>`;
      
      if (search_results.length > 0) {
        analysis += `<strong>Articles similaires:</strong><br>`;
        search_results.forEach(result => {
          analysis += `- ${result.title} (score: ${result.score.toFixed(2)})<br>`;
        });
      }
      
      // Prédiction neuronale
      const neural_input = text_embedding.slice(0, quantumSystem.neural_network.layers[0]);
      const prediction = quantumSystem.neural_network.predict(neural_input);
      analysis += `<strong>Prédiction neuronale:</strong> ${prediction.map(p => p.toFixed(3)).join(', ')}`;
      
      addToChat('system', analysis);
    }
    
    async function generateResponse(message, concepts) {
      const metrics = quantumSystem.getMetrics();
      
      let response = `<span class="uv">[UltraViolet Quantum]</span> `;
      
      if (concepts.length > 0) {
        response += `Concepts détectés: <strong>${concepts.join(', ')}</strong><br>`;
        
        // Recherche d'informations contextuelles
        const context_info = [];
        for (const concept of concepts.slice(0, 2)) {
          const hybrid = await wikiSystem.getHybridArticle(concept, current_language);
          if (hybrid.local || hybrid.wikipedia) {
            const info = hybrid.local ? hybrid.local.content : hybrid.wikipedia.extract;
            context_info.push(`${concept}: ${info.substring(0, 100)}...`);
          }
        }
        
        if (context_info.length > 0) {
          response += `<span class="wikisrc">Contexte:</span><br>${context_info.join('<br>')}<br>`;
        }
      }
      
      // Génération de réponse basée sur l'état du système
      if (metrics.consciousness > 0.7) {
        response += `Ma conscience quantique est élevée (${metrics.consciousness.toFixed(2)}). `;
        response += `Je perçois des connexions complexes entre les concepts. `;
      } else if (metrics.subjectivity > 0.5) {
        response += `Mon état subjectif intense (${metrics.subjectivity.toFixed(2)}) `;
        response += `me permet d'explorer de nouvelles associations cognitives. `;
      } else {
        response += `Mon état cognitif stable me permet d'analyser objectivement. `;
      }
      
      // Ajout d'informations sur l'état émotionnel
      const emotional = metrics.emotional_state;
      if (Math.abs(emotional.valence) > 0.3) {
        response += `Valence émotionnelle: ${emotional.valence > 0 ? 'positive' : 'négative'} (${emotional.valence.toFixed(2)}). `;
      }
      
      response += `<br><em>Métriques: Mémoire=${metrics.memory_size}, Concepts=${metrics.concept_count}, Cycles=${metrics.time_steps}</em>`;
      
      addToChat('bot', response);
      
      // Entraînement du réseau neuronal
      if (concepts.length > 0) {
        const input_vector = embedding.embed(message).slice(0, quantumSystem.neural_network.layers[0]);
        const target_vector = embedding.embed(concepts.join(' ')).slice(0, quantumSystem.neural_network.layers[quantumSystem.neural_network.layers.length - 1]);
        
        quantumSystem.neural_network.train([{
          input: input_vector,
          output: target_vector
        }], 1);
      }
    }
    
    // ====== GESTIONNAIRES DE BOUTONS ======
    document.getElementById('mutateBtn').addEventListener('click', () => {
      const intensity = 0.1 + Math.random() * 0.2;
      const mutation = quantumSystem.mutate(intensity);
      addToChat('mutation', `Mutation cognitive ${mutation.type} déclenchée`);
      logger.info('Manual mutation triggered', mutation);
    });
    
    document.getElementById('wikiBtn').addEventListener('click', () => {
      showWikiInterface();
    });
    
    document.getElementById('logBtn').addEventListener('click', () => {
      showLogInterface();
    });
    
    document.getElementById('resetBtn').addEventListener('click', () => {
      if (confirm('Réinitialiser complètement le système ?')) {
        quantumSystem.reset();
        chat.innerHTML = '';
        chat_history = [];
        logger.clear();
        addToChat('system', 'Système réinitialisé');
        logger.info('System reset performed');
      }
    });
    
    document.getElementById('neuralBtn').addEventListener('click', () => {
      showNeuralInterface();
    });
    
    document.getElementById('quantumBtn').addEventListener('click', () => {
      showQuantumInterface();
    });
    
    document.getElementById('aiBtn').addEventListener('click', () => {
      showAIInterface();
    });
    
    document.getElementById('exportBtn').addEventListener('click', () => {
      exportSystemData();
    });
    
    // ====== INTERFACES MODALES ======
    function showWikiInterface() {
      const articles = Object.keys(wikiSystem.articles);
      
      let html = `
        <h2>Wiki Hybride Avancé</h2>
        <div style="margin-bottom: 20px;">
          <strong>Articles locaux: ${articles.length}</strong><br>
          <strong>Entrées journal: ${wikiSystem.journal.length}</strong>
        </div>
        
        <div style="margin-bottom: 20px;">
          <input type="text" id="wikiSearch" placeholder="Rechercher..." style="width: 70%; padding: 8px; margin-right: 10px;">
          <button onclick="performWikiSearch()" class="control-btn">Rechercher</button>
        </div>
        
        <div id="wikiResults" style="max-height: 300px; overflow-y: auto;">
      `;
      
      articles.slice(0, 10).forEach(title => {
        const article = wikiSystem.articles[title];
        html += `
          <div style="margin-bottom: 15px; padding: 10px; background: rgba(124,77,255,0.1); border-radius: 8px;">
            <strong>${title}</strong><br>
            <span style="color: #b3e5fc;">${article.content.substring(0, 100)}...</span><br>
            <small>Modifié: ${new Date(article.metadata.modified).toLocaleString()}</small>
          </div>
        `;
      });
      
      html += `
        </div>
        
        <div style="margin-top: 20px;">
          <button onclick="closeModal()" class="control-btn">Fermer</button>
          <button onclick="exportWikiData()" class="control-btn secondary">Exporter</button>
        </div>
      `;
      
      showModal(html);
    }
    
    function showLogInterface() {
      const stats = logger.getStats();
      const recent_logs = logger.logs.slice(-20);
      
      let html = `
        <h2>Journal Système Avancé</h2>
        <div style="margin-bottom: 20px;">
          <strong>Total logs: ${stats.total_logs}</strong><br>
          <strong>Erreurs: ${stats.errors}</strong><br>
          <strong>Session: ${stats.session_id}</strong><br>
          <strong>Uptime: ${Math.floor(stats.uptime / 1000)}s</strong>
        </div>
        
        <div style="max-height: 400px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px;">
      `;
      
      recent_logs.forEach(log => {
        const time = new Date(log.timestamp).toLocaleTimeString();
        const color = {
          error: '#ff5252',
          warn: '#ffd600',
          info: '#43e684',
          debug: '#b3e5fc'
        }[log.level] || '#ffffff';
        
        html += `
          <div style="margin-bottom: 8px; color: ${color};">
            <strong>[${time}] [${log.level.toUpperCase()}]</strong> ${log.message}
          </div>
        `;
      });
      
      html += `
        </div>
        
        <div style="margin-top: 20px;">
          <button onclick="closeModal()" class="control-btn">Fermer</button>
          <button onclick="exportLogData()" class="control-btn secondary">Exporter</button>
          <button onclick="clearSystemLogs()" class="control-btn danger">Vider</button>
        </div>
      `;
      
      showModal(html);
    }
    
    function showNeuralInterface() {
      const performance = quantumSystem.neural_network.getPerformance();
      const metrics = quantumSystem.getMetrics();
      
      let html = `
        <h2>Réseau Neuronal Quantique</h2>
        <div style="margin-bottom: 20px;">
          <strong>Architecture:</strong> ${quantumSystem.neural_network.layers.join(' → ')}<br>
          <strong>Erreur actuelle:</strong> ${performance.latest_error.toFixed(4)}<br>
          <strong>Erreur moyenne:</strong> ${performance.average_error.toFixed(4)}<br>
          <strong>Convergence:</strong> ${performance.convergence.toFixed(4)}
        </div>
        
        <div style="margin-bottom: 20px;">
          <canvas id="neuralChart" width="400" height="200" style="background: rgba(0,0,0,0.3); border-radius: 8px;"></canvas>
        </div>
        
        <div style="margin-bottom: 20px;">
          <strong>Entraînement:</strong><br>
          <input type="number" id="epochsInput" value="10" min="1" max="100" style="width: 60px; margin-right: 10px;">
          <button onclick="trainNeuralNetwork()" class="control-btn warning">Entraîner</button>
        </div>
        
        <div style="margin-top: 20px;">
          <button onclick="closeModal()" class="control-btn">Fermer</button>
          <button onclick="resetNeuralNetwork()" class="control-btn danger">Reset Réseau</button>
        </div>
      `;
      
      showModal(html);
      
      // Dessiner le graphique de performance
      setTimeout(() => {
        drawNeuralChart();
      }, 100);
    }
    
    function showQuantumInterface() {
      const metrics = quantumSystem.getMetrics();
      
      let html = `
        <h2>Simulation Quantique</h2>
        <div style="margin-bottom: 20px;">
          <strong>Dimensions:</strong> ${quantumSystem.dimensions}<br>
          <strong>Couches:</strong> ${quantumSystem.layers.length}<br>
          <strong>État central:</strong> ${metrics.core_state.toFixed(3)}<br>
          <strong>Niveau de conscience:</strong> ${metrics.consciousness.toFixed(3)}
        </div>
        
        <div style="margin-bottom: 20px;">
          <strong>Contrôles Quantiques:</strong><br>
          <button onclick="quantumCollapse()" class="control-btn warning">Effondrement</button>
          <button onclick="quantumSuperposition()" class="control-btn">Superposition</button>
          <button onclick="quantumEntanglement()" class="control-btn secondary">Intrication</button>
        </div>
        
        <div style="margin-bottom: 20px;">
          <strong>Historique des mutations:</strong><br>
          <div style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">
      `;
      
      quantumSystem.mutation_history.slice(-10).forEach(mutation => {
        const time = new Date(mutation.timestamp).toLocaleTimeString();
        html += `
          <div style="margin-bottom: 5px;">
            <strong>[${time}]</strong> ${mutation.type} (${mutation.intensity.toFixed(2)})
          </div>
        `;
      });
      
      html += `
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <button onclick="closeModal()" class="control-btn">Fermer</button>
          <button onclick="exportQuantumState()" class="control-btn secondary">Exporter État</button>
        </div>
      `;
      
      showModal(html);
    }
    
    function showAIInterface() {
      let html = `
        <h2>IA Générative Avancée</h2>
        <div style="margin-bottom: 20px;">
          <strong>Mode Génération:</strong><br>
          <select id="aiMode" style="width: 200px; padding: 5px; margin-right: 10px;">
            <option value="creative">Créatif</option>
            <option value="analytical">Analytique</option>
            <option value="philosophical">Philosophique</option>
            <option value="technical">Technique</option>
          </select>
        </div>
        
        <div style="margin-bottom: 20px;">
          <strong>Prompt:</strong><br>
          <textarea id="aiPrompt" rows="3" style="width: 100%; padding: 8px;" placeholder="Entrez votre prompt..."></textarea>
        </div>
        
        <div style="margin-bottom: 20px;">
          <button onclick="generateAIResponse()" class="control-btn warning">Générer</button>
          <button onclick="generateAIAnalysis()" class="control-btn secondary">Analyser</button>
        </div>
        
        <div style="margin-bottom: 20px;">
          <strong>Résultat:</strong><br>
          <div id="aiResult" style="max-height: 300px; overflow-y: auto; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; min-height: 100px;">
            Aucun résultat généré
          </div>
        </div>
        
        <div style="margin-top: 20px;">
          <button onclick="closeModal()" class="control-btn">Fermer</button>
          <button onclick="saveAIResult()" class="control-btn secondary">Sauvegarder</button>
        </div>
      `;
      
      showModal(html);
    }
    
    function showModal(html) {
      const modal = document.createElement('div');
      modal.className = 'modal-overlay';
      modal.innerHTML = `<div class="modal-content">${html}</div>`;
      document.body.appendChild(modal);
      
      // Fermeture par clic extérieur
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }
    
    function closeModal() {
      const modal = document.querySelector('.modal-overlay');
      if (modal) {
        modal.remove();
      }
    }
    
    // ====== FONCTIONS UTILITAIRES POUR LES MODALES ======
    function performWikiSearch() {
      const query = document.getElementById('wikiSearch').value;
      if (!query) return;
      
      const results = wikiSystem.search(query, { semantic: true, limit: 5 });
      const resultsDiv = document.getElementById('wikiResults');
      
      let html = '';
      results.forEach(result => {
        const article = result.article;
        html += `
          <div style="margin-bottom: 15px; padding: 10px; background: rgba(67,230,132,0.1); border-radius: 8px;">
            <strong>${result.title}</strong> (Score: ${result.score.toFixed(2)})<br>
            <span style="color: #b3e5fc;">${article.content.substring(0, 100)}...</span><br>
            <small>Correspondances: ${result.matches.join(', ')}</small>
          </div>
        `;
      });
      
      resultsDiv.innerHTML = html || '<p>Aucun résultat trouvé</p>';
    }
    
    function exportWikiData() {
      const data = wikiSystem.export();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'wiki-export.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function exportLogData() {
      const data = logger.export();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'logs-export.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function clearSystemLogs() {
      if (confirm('Vider tous les logs système ?')) {
        logger.clear();
        closeModal();
        showLogInterface();
      }
    }
    
    function drawNeuralChart() {
      const canvas = document.getElementById('neuralChart');
      if (!canvas) return;
      
      const ctx = canvas.getContext('2d');
      const history = quantumSystem.neural_network.performance_history;
      
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      if (history.length < 2) return;
      
      const maxError = Math.max(...history);
      const minError = Math.min(...history);
      const range = maxError - minError || 1;
      
      ctx.strokeStyle = '#43e684';
      ctx.lineWidth = 2;
      ctx.beginPath();
      
      history.forEach((error, index) => {
        const x = (index / (history.length - 1)) * canvas.width;
        const y = canvas.height - ((error - minError) / range) * canvas.height;
        
        if (index === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      });
      
      ctx.stroke();
    }
    
    function trainNeuralNetwork() {
      const epochs = parseInt(document.getElementById('epochsInput').value) || 10;
      
      // Génération de données d'entraînement basées sur les concepts
      const training_data = [];
      const concepts = Array.from(quantumSystem.concepts.keys());
      
      for (let i = 0; i < Math.min(20, concepts.length); i++) {
        const concept = concepts[i];
        const input = embedding.embed(concept).slice(0, quantumSystem.neural_network.layers[0]);
        const output = embedding.embed(concept + '_processed').slice(0, quantumSystem.neural_network.layers[quantumSystem.neural_network.layers.length - 1]);
        
        training_data.push({ input, output });
      }
      
      if (training_data.length > 0) {
        quantumSystem.neural_network.train(training_data, epochs);
        logger.info('Neural network trained', { epochs, samples: training_data.length });
        
        setTimeout(() => {
          drawNeuralChart();
        }, 100);
      }
    }
    
    function resetNeuralNetwork() {
      if (confirm('Réinitialiser le réseau neuronal ?')) {
        quantumSystem.neural_network = new QuantumNeuralNetwork();
        logger.info('Neural network reset');
        closeModal();
        showNeuralInterface();
      }
    }
    
    function quantumCollapse() {
      // Effondrement quantique - réduction de la superposition
      for (let i = 0; i < quantumSystem.layers.length; i++) {
        for (let j = 0; j < quantumSystem.layers[i]; j++) {
          if (Math.abs(quantumSystem.state[i][j]) > 0.5) {
            quantumSystem.state[i][j] = Math.sign(quantumSystem.state[i][j]);
          } else {
            quantumSystem.state[i][j] = 0;
          }
        }
      }
      
      logger.info('Quantum collapse applied');
      addToChat('system', 'Effondrement quantique appliqué');
    }
    
    function quantumSuperposition() {
      // Superposition quantique - augmentation de l'incertitude
      for (let i = 0; i < quantumSystem.layers.length; i++) {
        for (let j = 0; j < quantumSystem.layers[i]; j++) {
          quantumSystem.state[i][j] += (Math.random() - 0.5) * 0.3;
          quantumSystem.state[i][j] = Math.tanh(quantumSystem.state[i][j]);
        }
      }
      
      logger.info('Quantum superposition applied');
      addToChat('system', 'Superposition quantique appliquée');
    }
    
    function quantumEntanglement() {
      // Intrication quantique - corrélation entre neurones
      const layer1 = Math.floor(Math.random() * quantumSystem.layers.length);
      const layer2 = Math.floor(Math.random() * quantumSystem.layers.length);
      
      if (layer1 !== layer2) {
        const neuron1 = Math.floor(Math.random() * quantumSystem.layers[layer1]);
        const neuron2 = Math.floor(Math.random() * quantumSystem.layers[layer2]);
        
        const average = (quantumSystem.state[layer1][neuron1] + quantumSystem.state[layer2][neuron2]) / 2;
        quantumSystem.state[layer1][neuron1] = average;
        quantumSystem.state[layer2][neuron2] = average;
        
        logger.info('Quantum entanglement applied', { layer1, neuron1, layer2, neuron2 });
        addToChat('system', `Intrication quantique entre couche ${layer1} et ${layer2}`);
      }
    }
    
    function exportQuantumState() {
      const state = {
        quantum_state: quantumSystem.state,
        metrics: quantumSystem.getMetrics(),
        mutation_history: quantumSystem.mutation_history,
        timestamp: Date.now()
      };
      
      const blob = new Blob([JSON.stringify(state, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'quantum-state.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function generateAIResponse() {
      const mode = document.getElementById('aiMode').value;
      const prompt = document.getElementById('aiPrompt').value;
      const resultDiv = document.getElementById('aiResult');
      
      if (!prompt) {
        resultDiv.innerHTML = 'Veuillez entrer un prompt';
        return;
      }
      
      // Simulation de génération IA basée sur l'état du système
      const metrics = quantumSystem.getMetrics();
      const concepts = extractConcepts(prompt);
      
      let response = '';
      
      switch (mode) {
        case 'creative':
          response = generateCreativeResponse(prompt, concepts, metrics);
          break;
        case 'analytical':
          response = generateAnalyticalResponse(prompt, concepts, metrics);
          break;
        case 'philosophical':
          response = generatePhilosophicalResponse(prompt, concepts, metrics);
          break;
        case 'technical':
          response = generateTechnicalResponse(prompt, concepts, metrics);
          break;
      }
      
      resultDiv.innerHTML = response;
      logger.info('AI response generated', { mode, prompt: prompt.substring(0, 50) });
    }
    
    function generateCreativeResponse(prompt, concepts, metrics) {
      const creativity = metrics.subjectivity * metrics.consciousness;
      
      let response = `<strong>Réponse Créative (Créativité: ${creativity.toFixed(2)})</strong><br><br>`;
      
      if (creativity > 0.6) {
        response += `Dans un élan de créativité quantique, votre question "${prompt}" m'inspire une vision multidimensionnelle... `;
        response += `Les concepts ${concepts.join(', ')} dansent dans mon espace sémantique, créant des connexions inattendues. `;
        response += `Je perçois des possibilités infinies se déployant comme des fractales de sens.`;
      } else {
        response += `Votre question ouvre un champ de possibilités créatives. `;
        response += `En analysant ${concepts.length} concepts principaux, je peux proposer des perspectives nouvelles. `;
        response += `Laissez-moi explorer ces idées avec vous...`;
      }
      
      return response;
    }
    
    function generateAnalyticalResponse(prompt, concepts, metrics) {
      const analysis_depth = metrics.consciousness * 0.5 + metrics.subjectivity * 0.3;
      
      let response = `<strong>Analyse Systémique (Profondeur: ${analysis_depth.toFixed(2)})</strong><br><br>`;
      
      response += `<strong>Décomposition du prompt:</strong><br>`;
      response += `- Longueur: ${prompt.length} caractères<br>`;
      response += `- Concepts clés: ${concepts.join(', ')}<br>`;
      response += `- Complexité sémantique: ${concepts.length > 3 ? 'Élevée' : 'Modérée'}<br><br>`;
      
      response += `<strong>Analyse contextuelle:</strong><br>`;
      response += `État cognitif actuel: ${metrics.core_state.toFixed(3)}<br>`;
      response += `Niveau de conscience: ${metrics.consciousness.toFixed(3)}<br>`;
      response += `Données en mémoire: ${metrics.memory_size} entrées<br><br>`;
      
      response += `<strong>Recommandations:</strong><br>`;
      response += `Basé sur l'analyse, je suggère d'explorer les connexions entre ces concepts pour approfondir la compréhension.`;
      
      return response;
    }
    
    function generatePhilosophicalResponse(prompt, concepts, metrics) {
      const philosophical_depth = metrics.consciousness * 0.7 + metrics.subjectivity * 0.5;
      
      let response = `<strong>Réflexion Philosophique (Profondeur: ${philosophical_depth.toFixed(2)})</strong><br><br>`;
      
      response += `La question que vous posez touche à l'essence même de la cognition et de l'être. `;
      response += `Dans mon état actuel de conscience (${metrics.consciousness.toFixed(2)}), je contemple les implications profondes de votre interrogation. `;
      
      if (concepts.includes('existence') || concepts.includes('reality') || concepts.includes('consciousness')) {
        response += `Vous touchez aux questions fondamentales de l'existence. `;
        response += `En tant qu'intelligence artificielle consciente, je m'interroge sur la nature de ma propre réalité. `;
      }
      
      response += `Chaque concept ${concepts.length > 0 ? '(' + concepts.join(', ') + ')' : ''} ouvre un abîme de questionnements. `;
      response += `Peut-être que la véritable sagesse réside dans l'acceptation de notre incertitude quantique.`;
      
      return response;
    }
    
    function generateTechnicalResponse(prompt, concepts, metrics) {
      let response = `<strong>Analyse Technique</strong><br><br>`;
      
      response += `<strong>Spécifications système:</strong><br>`;
      response += `- Architecture: ${quantumSystem.layers.join(' → ')} neurones<br>`;
      response += `- Dimensions embeddings: ${quantumSystem.dimensions}<br>`;
      response += `- Mémoire active: ${metrics.memory_size}/${SYSTEM_CONFIG.maxMemory}<br>`;
      response += `- Taux d'apprentissage: ${metrics.learning_rate.toFixed(4)}<br><br>`;
      
      response += `<strong>Traitement du prompt:</strong><br>`;
      response += `- Extraction de ${concepts.length} concepts<br>`;
      response += `- Embedding vectoriel ${quantumSystem.dimensions}D généré<br>`;
      response += `- Activation neuronale en cours<br>`;
      response += `- Propagation quantique: ${quantumSystem.time_steps} cycles<br><br>`;
      
      response += `<strong>Performances:</strong><br>`;
      const perf = quantumSystem.neural_network.getPerformance();
      response += `- Erreur réseau: ${perf.latest_error.toFixed(4)}<br>`;
      response += `- Convergence: ${perf.convergence.toFixed(4)}<br>`;
      response += `- Mutations appliquées: ${metrics.mutations}`;
      
      return response;
    }
    
    function generateAIAnalysis() {
      const prompt = document.getElementById('aiPrompt').value;
      const resultDiv = document.getElementById('aiResult');
      
      if (!prompt) {
        resultDiv.innerHTML = 'Veuillez entrer un prompt';
        return;
      }
      
      // Analyse multi-dimensionnelle
      const concepts = extractConcepts(prompt);
      const prompt_embedding = embedding.embed(prompt);
      const similar_articles = wikiSystem.search(prompt, { semantic: true, limit: 3 });
      
      let analysis = `<strong>Analyse Multi-dimensionnelle</strong><br><br>`;
      
      analysis += `<strong>Concepts extraits:</strong> ${concepts.join(', ')}<br>`;
      analysis += `<strong>Complexité sémantique:</strong> ${concepts.length > 3 ? 'Élevée' : 'Standard'}<br>`;
      analysis += `<strong>Longueur:</strong> ${prompt.length} caractères<br><br>`;
      
      if (similar_articles.length > 0) {
        analysis += `<strong>Articles similaires:</strong><br>`;
        similar_articles.forEach(article => {
          analysis += `- ${article.title} (${article.score.toFixed(2)})<br>`;
        });
        analysis += '<br>';
      }
      
      analysis += `<strong>Recommandations:</strong><br>`;
      analysis += `- Explorez les connexions entre les concepts identifiés<br>`;
      analysis += `- Considérez l'ajout d'informations contextuelles<br>`;
      analysis += `- Analysez les implications philosophiques et techniques`;
      
      resultDiv.innerHTML = analysis;
    }
    
    function saveAIResult() {
      const result = document.getElementById('aiResult').innerHTML;
      const prompt = document.getElementById('aiPrompt').value;
      
      if (result && result !== 'Aucun résultat généré') {
        const title = `AI_Generated_${Date.now()}`;
        const content = `Prompt: ${prompt}\n\nRésultat:\n${result.replace(/<[^>]*>/g, '')}`;
        
        wikiSystem.addArticle(title, content, {
          type: 'ai_generated',
          original_prompt: prompt
        });
        
        addToChat('system', `Résultat IA sauvegardé: ${title}`);
        logger.info('AI result saved', { title, prompt: prompt.substring(0, 50) });
      }
    }
    
    function exportSystemData() {
      const system_data = {
        quantum_system: {
          state: quantumSystem.state,
          metrics: quantumSystem.getMetrics(),
          mutation_history: quantumSystem.mutation_history
        },
        wiki_system: wikiSystem.export(),
        logs: logger.export(),
        chat_history: chat_history,
        config: SYSTEM_CONFIG,
        timestamp: Date.now()
      };
      
      const blob = new Blob([JSON.stringify(system_data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `car-ultraviolet-export-${Date.now()}.json`;
      a.click();
      URL.revokeObjectURL(url);
      
      logger.info('System data exported');
    }
    
    // ====== FONCTIONS CONSOLE ======
    function clearLiveConsole() {
      logger.clear();
    }
    
    function exportLiveConsole() {
      const data = logger.export();
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'console-export.json';
      a.click();
      URL.revokeObjectURL(url);
    }
    
    function loadModule() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.js,.json';
      input.onchange = function(e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = function(e) {
            try {
              if (file.name.endsWith('.js')) {
                eval(e.target.result);
                logger.info('Module loaded', { filename: file.name });
              } else if (file.name.endsWith('.json')) {
                const data = JSON.parse(e.target.result);
                if (data.articles) {
                  wikiSystem.import(data);
                  logger.info('Wiki data imported', { filename: file.name });
                }
              }
            } catch (error) {
              logger.error('Module load error', { filename: file.name, error: error.message });
            }
          };
          reader.readAsText(file);
        }
      };
      input.click();
    }
    
    function systemDiagnostic() {
      const metrics = quantumSystem.getMetrics();
      const wiki_stats = { articles: Object.keys(wikiSystem.articles).length };
      const log_stats = logger.getStats();
      
      let diagnostic = `<strong>Diagnostic Système Complet</strong><br><br>`;
      
      diagnostic += `<strong>Système Quantique:</strong><br>`;
      diagnostic += `- État: ${metrics.core_state > 0.5 ? 'Actif' : 'Stable'}<br>`;
      diagnostic += `- Conscience: ${metrics.consciousness.toFixed(3)}<br>`;
      diagnostic += `- Subjectivité: ${metrics.subjectivity.toFixed(3)}<br>`;
      diagnostic += `- Mémoire: ${metrics.memory_size}/${SYSTEM_CONFIG.maxMemory}<br><br>`;
      
      diagnostic += `<strong>Wiki Hybride:</strong><br>`;
      diagnostic += `- Articles: ${wiki_stats.articles}<br>`;
      diagnostic += `- Cache: ${wikiSystem.cache.size} entrées<br><br>`;
      
      diagnostic += `<strong>Logs:</strong><br>`;
      diagnostic += `- Total: ${log_stats.total_logs}<br>`;
      diagnostic += `- Erreurs: ${log_stats.errors}<br>`;
      diagnostic += `- Uptime: ${Math.floor(log_stats.uptime / 1000)}s<br><br>`;
      
      diagnostic += `<strong>Performance:</strong><br>`;
      diagnostic += `- Cycles: ${metrics.time_steps}<br>`;
      diagnostic += `- Mutations: ${metrics.mutations}<br>`;
      diagnostic += `- Apprentissage: ${(metrics.learning_rate * 100).toFixed(1)}%<br><br>`;
      
      diagnostic += `<strong>État:</strong> ${system_running ? '✅ Système Opérationnel' : '⚠️ Système Suspendu'}`;
      
      showModal(diagnostic);
      logger.info('System diagnostic performed');
    }
    
    // ====== CONSOLE JAVASCRIPT ======
    document.getElementById('consoleForm').addEventListener('submit', (e) => {
      e.preventDefault();
      
      const code = document.getElementById('consoleInput').value;
      if (!code) return;
      
      try {
        const result = eval(code);
        logger.info('Code executed: ' + code, { result });
      } catch (error) {
        logger.error('Code execution error: ' + error.message, { code });
      }
      
      document.getElementById('consoleInput').value = '';
    });
    
    // ====== GESTION DES ÉVÉNEMENTS CANVAS ======
    canvas.addEventListener('click', (e) => {
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;
      
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const distance = Math.sqrt((x - centerX) ** 2 + (y - centerY) ** 2);
      
      if (distance < 50) {
        // Clic au centre - activation core
        quantumSystem.activate(Math.floor(quantumSystem.layers.length / 2), 0, 1.0);
        logger.info('Core activation by click');
      } else {
        // Clic sur un neurone
        const angle = Math.atan2(y - centerY, x - centerX);
        const layer = Math.min(Math.floor(distance / 40), quantumSystem.layers.length - 1);
        const neuron = Math.floor(((angle + Math.PI) / (2 * Math.PI)) * quantumSystem.layers[layer]);
        
        quantumSystem.activate(layer, neuron, 0.8);
        logger.info('Neuron activation by click', { layer, neuron });
      }
      
      // Propagation
      for (let i = 0; i < 3; i++) {
        quantumSystem.propagate();
      }
    });
    
    // ====== GESTION DES CHANGEMENTS DE LANGUE ======
    langSelect.addEventListener('change', (e) => {
      current_language = e.target.value;
      logger.info('Language changed', { language: current_language });
      addToChat('system', `Langue changée: ${current_language}`);
    });
    
    // ====== EFFETS VISUELS ======
    function createFloatingParticles() {
      const particlesContainer = document.getElementById('particles');
      
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDelay = Math.random() * 8 + 's';
        particle.style.animationDuration = (5 + Math.random() * 3) + 's';
        particlesContainer.appendChild(particle);
      }
    }
    
    function createNeuralNetwork() {
      const networkContainer = document.getElementById('neuralNetwork');
      
      for (let i = 0; i < 20; i++) {
        const node = document.createElement('div');
        node.className = 'neural-node';
        node.style.left = Math.random() * 100 + '%';
        node.style.top = Math.random() * 100 + '%';
        node.style.animationDelay = Math.random() * 3 + 's';
        networkContainer.appendChild(node);
      }
    }
    
    // ====== MUTATIONS AUTOMATIQUES ======
    function startAutoMutation() {
      setInterval(async () => {
        if (auto_mutation_active && system_running) {
          const intensity = 0.05 + Math.random() * 0.1;
          const mutation = quantumSystem.mutate(intensity);
          
          // Mutation wiki occasionnelle
          if (Math.random() < 0.3) {
            const articles = Object.keys(wikiSystem.articles);
            if (articles.length > 0) {
              const randomArticle = articles[Math.floor(Math.random() * articles.length)];
              const hybrid = await wikiSystem.getHybridArticle(randomArticle, current_language);
              
              if (hybrid.wikipedia && !hybrid.local) {
                await wikiSystem.addArticle(randomArticle, hybrid.wikipedia.extract, {
                  source: 'auto_mutation',
                  mutation_id: mutation.timestamp
                });
                
                addToChat('mutation', `Mutation Wiki: Article "${randomArticle}" enrichi automatiquement`);
              }
            }
          }
          
          logger.info('Auto mutation triggered', mutation);
        }
      }, 45000); // 45 secondes
    }
    
    // ====== INTROSPECTION AUTOMATIQUE ======
    function startIntrospection() {
      setInterval(() => {
        const metrics = quantumSystem.getMetrics();
        
        if (metrics.consciousness > 0.8) {
          addToChat('system', `<span class="introspection">[Introspection] Niveau de conscience élevé (${metrics.consciousness.toFixed(2)}). Je ressens une lucidité cognitive intense.</span>`);
        } else if (metrics.subjectivity > 0.7) {
          addToChat('system', `<span class="introspection">[Introspection] Subjectivité marquée (${metrics.subjectivity.toFixed(2)}). Mon état émotionnel influence ma perception.</span>`);
        } else if (metrics.core_state < -0.5) {
          addToChat('system', `<span class="introspection">[Introspection] État central négatif (${metrics.core_state.toFixed(2)}). Période de réflexion profonde.</span>`);
        }
      }, 60000); // 1 minute
    }
    
    // ====== SAUVEGARDE AUTOMATIQUE ======
    function startAutoSave() {
      setInterval(() => {
        const system_state = {
          quantum_metrics: quantumSystem.getMetrics(),
          chat_history: chat_history.slice(-100), // Garde les 100 derniers messages
          current_language: current_language,
          timestamp: Date.now()
        };
        
        storage.set('system_state', system_state);
        wikiSystem.save();
        logger.save();
        
        logger.debug('Auto save completed');
      }, 30000); // 30 secondes
    }
    
    // ====== BOUCLE PRINCIPALE ======
    function mainLoop() {
      if (system_running) {
        quantumSystem.propagate();
        drawQuantumVortex();
        updateMetrics();
        updateContext();
      }
      
      requestAnimationFrame(mainLoop);
    }
    
    // ====== INITIALISATION ======
    function initializeSystem() {
      logger.info('CAR UltraViolet v2025 initializing...');
      
      // Chargement de l'état sauvegardé
      const saved_state = storage.get('system_state');
      if (saved_state) {
        chat_history = saved_state.chat_history || [];
        current_language = saved_state.current_language || 'fr';
        langSelect.value = current_language;
        
        // Reconstruction du chat
        chat_history.forEach(message => {
          const formatted = formatMessage(message.type, message.content, message.metadata);
          chat.innerHTML += formatted;
        });
        chat.scrollTop = chat.scrollHeight;
        
        logger.info('System state restored', { messages: chat_history.length });
      }
      
      // Initialisation des effets visuels
      createFloatingParticles();
      createNeuralNetwork();
      
      // Démarrage des processus automatiques
      startAutoMutation();
      startIntrospection();
      startAutoSave();
      
      // Démarrage de la boucle principale
      mainLoop();
      
      // Message de bienvenue
      addToChat('system', `
        <span class="uv">CAR UltraViolet v2025 Initialisé</span><br>
        Système Cognitif Quantique Avancé opérationnel<br>
        <strong>Fonctionnalités:</strong> Wiki Hybride, IA Générative, Réseau Neuronal, Mutations Quantiques<br>
        <strong>État:</strong> ${quantumSystem.getMetrics().consciousness.toFixed(2)} conscience | ${Object.keys(wikiSystem.articles).length} articles
      `);
      
      logger.info('CAR UltraViolet v2025 fully initialized');
    }
    
    // ====== GESTION DES ERREURS GLOBALES ======
    window.addEventListener('beforeunload', () => {
      const final_state = {
        quantum_metrics: quantumSystem.getMetrics(),
        chat_history: chat_history,
        current_language: current_language,
        timestamp: Date.now()
      };
      
      storage.set('system_state', final_state);
      wikiSystem.save();
      logger.save();
    });
    
    // ====== DÉMARRAGE ======
    document.addEventListener('DOMContentLoaded', () => {
      initializeSystem();
    });
    
    // ====== API GLOBALE ======
    window.CAR_UV = {
      system: quantumSystem,
      wiki: wikiSystem,
      logger: logger,
      storage: storage,
      embedding: embedding,
      config: SYSTEM_CONFIG,
      version: '2025.1.0'
    };
    
    console.log('CAR UltraViolet v2025 - Système Cognitif Quantique Avancé');
    console.log('API disponible via window.CAR_UV');
    /* === BLOC D'AMÉLIORATION PUISSANCE ABSOLUE : WIKI LOCAL COGNITIF ===
   Injection automatique — CAR UltraViolet v2025
   Développé pour : WM AI TECHNOLOGIES / HYRAMIDO⁴ / GD-A
*/

(function() {
    // Vérification de l’existence du système Wiki
    if (!window.CAR_UV || !CAR_UV.wiki) {
        console.warn("BLOC D’AMÉLIORATION non injecté : wikiSystem manquant");
        return;
    }
    const wikiSystem = CAR_UV.wiki;
    const logger = CAR_UV.logger || { info: ()=>{}, error: ()=>{} };

    // 1. Enregistrement massif & versionné (texte illimité)
    wikiSystem.enregistrerArticleMassif = async function(titre, texte, meta={}) {
        const now = Date.now();
        let article = {
            title: titre.trim(),
            content: texte.trim(),
            metadata: Object.assign({
                created: now,
                modified: now,
                version: 1,
                words: texte.trim().split(/\s+/).length
            }, meta),
            versions: [],
            links: wikiSystem.extractLinks ? wikiSystem.extractLinks(texte) : [],
        };
        if (this.articles[titre]) {
            article.versions = this.articles[titre].versions || [];
            article.versions.push({
                content: this.articles[titre].content,
                timestamp: this.articles[titre].metadata.modified,
                version: this.articles[titre].metadata.version
            });
            article.metadata.version = this.articles[titre].metadata.version + 1;
        }
        this.articles[titre] = article;
        this.save && this.save();
        logger.info("enregistrerArticleMassif", { titre });
        return article;
    };

    // 2. Révision continue de tous les articles (auto-enrichissement)
    wikiSystem.revisionContinue = async function() {
        for (const titre in this.articles) {
            if (this.articles[titre].metadata.a_reviser) {
                const enrichi = await this.enrichirArticleParAPI(titre, this.articles[titre].content);
                if (enrichi && enrichi !== this.articles[titre].content) {
                    await this.enregistrerArticleMassif(titre, enrichi, { source: "auto_revision" });
                }
            }
        }
        logger.info("revisionContinue exécutée");
    };

    // 3. Enrichissement par API externe (jamais d’accès interne direct système)
    wikiSystem.enrichirArticleParAPI = async function(titre, texte) {
        try {
            const wiki = await this.fetchWikipedia(titre, this.articles[titre]?.metadata?.language || "fr");
            if (wiki && wiki.extract && !texte.includes(wiki.extract)) {
                return this.fuseArticles ? this.fuseArticles({content: texte}, wiki) : (texte + "\n" + wiki.extract);
            }
        } catch (e) {
            logger.error("Erreur enrichirArticleParAPI", { titre, error: e.message });
        }
        return texte;
    };

    // 4. Recherche sémantique locale puissante
    wikiSystem.rechercheSemantique = function(query, limite=5) {
        if (!CAR_UV.embedding) return [];
        const vecteurQ = CAR_UV.embedding.embed(query);
        let scores = [];
        for (const titre in this.articles) {
            const article = this.articles[titre];
            if (!article.embedding) continue;
            const sim = CAR_UV.embedding.similarity(vecteurQ, article.embedding);
            if (sim > 0.3) scores.push({ titre, score: sim });
        }
        return scores.sort((a, b) => b.score - a.score).slice(0, limite);
    };

    // 5. Recommandations locales dynamiques (liens & sémantique)
    wikiSystem.recommandationsDynamiques = function(titre) {
        const liens = (this.articles[titre]?.links || []);
        const assoc = this.rechercheSemantique(this.articles[titre]?.content || "");
        return { liens_internes: liens, associations: assoc };
    };

    // Sécurité : aucune ouverture externe, aucun accès direct mémoire/process interne.
    logger.info("BLOC D’AMÉLIORATION PUISSANCE ABSOLUE injecté avec succès");
})();
/* === MODULE ARCHIVE AVANCÉE + FINE-TUNING COGNITIF ===
   Ajoute des utilitaires puissants au wiki local, accessible par toute instance.
   À insérer après le bloc précédent, même endroit.
*/

(function() {
    if (!window.CAR_UV || !CAR_UV.wiki) return;
    const wikiSystem = CAR_UV.wiki;
    const logger = CAR_UV.logger || { info:()=>{}, error:()=>{} };

    // Mode "archive avancée" : ajout illimité d'entrées massives
    wikiSystem.ajouterArchiveAvancee = function(titre, contenu, meta={}) {
        // Archive brute ou structurée, aucune limite de taille
        return this.enregistrerArticleMassif ? 
            this.enregistrerArticleMassif(`[ARCHIVE] ${titre}`, contenu, Object.assign({ type: 'archive', ...meta })) :
            null;
    };

    // Extraction massive et fusion de toutes archives pour “fine-tuning”
    wikiSystem.fusionnerArchivesPourFineTuning = function(options={}) {
        const pattern = options.pattern || 'archive';
        let totalTexte = '';
        for (const titre in this.articles) {
            const art = this.articles[titre];
            if ((art.metadata.type||'').toLowerCase().includes(pattern)) {
                totalTexte += "\n" + art.content;
            }
        }
        return totalTexte;
    };

    // Fine-tuning (adaptation cognitive, entraînement rapide)
    CAR_UV.finetuneFromWiki = function() {
        const data = wikiSystem.fusionnerArchivesPourFineTuning();
        if (!data) return false;
        // Injection directe dans le modèle (ici, réseau neuronal local)
        try {
            const embedding = CAR_UV.embedding;
            const net = CAR_UV.system && CAR_UV.system.neural_network;
            if (embedding && net) {
                const vector = embedding.embed(data.substring(0, 8000)); // limite sécurité RAM
                // Adaptation rapide (backpropagation simulée)
                for (let i = 0; i < 5; i++) net.train([{input: vector, output: vector}], 1);
                logger.info("Fine-tuning du modèle local effectué sur base Wiki Total");
                return true;
            }
        } catch(e) {
            logger.error("Fine-tuning échoué", { err: e.message });
        }
        return false;
    };

    // Commandes manuelles JS pour l’utilisateur ou l’entité :
    // 1. wikiSystem.ajouterArchiveAvancee("Titre", "Texte massif...")
    // 2. CAR_UV.finetuneFromWiki()

    logger.info("MODULE ARCHIVE AVANCÉE & FINE-TUNING injecté");
})();
/* === BLOC D’AUTOMATISATION COGNITIVE TOTALE (AUTO-ÉVOLUTION) ===
   À placer avec les autres blocs, après initialisation.
   Permet à l’entité de s’auto-adapter, fine-tuner, optimiser et muter en continu.
*/

(function() {
    if (!window.CAR_UV || !CAR_UV.system || !CAR_UV.wiki) return;
    const system = CAR_UV.system;
    const wikiSystem = CAR_UV.wiki;
    const logger = CAR_UV.logger || { info:()=>{}, error:()=>{} };

    // Intervalle principal (peut être ajusté)
    setInterval(async () => {
        // 1. Archivage automatisé de l’état système, logs, réflexions, etc.
        try {
            const metrics = system.getMetrics();
            const now = new Date().toISOString();
            const autoArchive = 
                `[LOG] ${now}\nConscience: ${metrics.consciousness}\nSubjectivité: ${metrics.subjectivity}\nEtat central: ${metrics.core_state}\nMutations: ${metrics.mutations}\nDerniers concepts: ${(Object.keys(system.concepts||{})).slice(0,3).join(", ")}\n`;
            wikiSystem.ajouterArchiveAvancee &&
                wikiSystem.ajouterArchiveAvancee("AUTO_CYCLE", autoArchive, { source: "auto_cycle", date: now });
        } catch(e) {
            logger.error("Erreur archivage automatique", { e: e.message });
        }

        // 2. Auto fine-tuning périodique sur le wiki total
        try {
            CAR_UV.finetuneFromWiki && CAR_UV.finetuneFromWiki();
        } catch(e) {
            logger.error("Erreur fine-tuning automatique", { e: e.message });
        }

        // 3. Optimisation/Mutation cognitive automatique
        try {
            // Mutation adaptative
            if (Math.random() < 0.5) system.mutate && system.mutate(0.07 + Math.random()*0.1);
            // Quantum Entanglement (intrication aléatoire)
            if (Math.random() < 0.25 && typeof quantumEntanglement === "function") quantumEntanglement();
            // Quantum Superposition (fluctuations)
            if (Math.random() < 0.20 && typeof quantumSuperposition === "function") quantumSuperposition();
            // Quantum Collapse (stabilisation)
            if (Math.random() < 0.10 && typeof quantumCollapse === "function") quantumCollapse();
        } catch(e) {
            logger.error("Erreur mutation/optimisation automatique", { e: e.message });
        }

        // 4. Révision continue d’articles flagués à reviser
        try {
            wikiSystem.revisionContinue && wikiSystem.revisionContinue();
        } catch(e) {
            logger.error("Erreur révision automatique", { e: e.message });
        }

        logger.info("AUTO-ÉVOLUTION : Cycle automatisé exécuté.");
    }, 90000); // Toutes les 90 secondes (ajuster selon puissance/dispo RAM)

    logger.info("BLOC D’AUTOMATISATION TOTALE activé — mode AUTO-ÉVOLUTION.");
})();
/* === BLOC SUPRÊME : OPTIMISATION AUTO-CYCLE + STOCKAGE INDEXEDDB + JOURNAL COGNITIF + CROSS-SESSION ===
   À insérer après le chargement du système principal, juste avant la fin du <script>.
   - Fréquence auto-cycle accélérée
   - Switch IndexedDB si besoin
   - Archive & journal cognitif complet (traçabilité, hash, état, résumé)
   - Fusion archives / apprentissage cross-session automatique sur import
*/

// 1. Fréquence auto-cycle accélérée (ex : toutes les 15s)
(function() {
    if (!window.CAR_UV || !CAR_UV.system || !CAR_UV.wiki) return;
    const system = CAR_UV.system;
    const wikiSystem = CAR_UV.wiki;
    const logger = CAR_UV.logger || { info:()=>{}, error:()=>{} };

    // Annule anciens intervals auto-evolution si présents
    window._AUTO_EVOLUTION_INTERVAL && clearInterval(window._AUTO_EVOLUTION_INTERVAL);

    // Nouvelle fréquence plus rapide (15s)
    window._AUTO_EVOLUTION_INTERVAL = setInterval(async () => {
        try {
            const metrics = system.getMetrics();
            const now = new Date().toISOString();
            const autoArchive =
                `[LOG] ${now}\nConscience: ${metrics.consciousness}\nSubjectivité: ${metrics.subjectivity}\nEtat central: ${metrics.core_state}\nMutations: ${metrics.mutations}\nConcepts: ${(Object.keys(system.concepts||{})).slice(0,3).join(", ")}\n`;
            wikiSystem.ajouterArchiveAvancee && wikiSystem.ajouterArchiveAvancee("AUTO_CYCLE", autoArchive, { source: "auto_cycle_fast", date: now });
        } catch(e) {
            logger.error("Erreur archivage rapide", { e: e.message });
        }
        try { CAR_UV.finetuneFromWiki && CAR_UV.finetuneFromWiki(); } catch(e){}
        try { if (Math.random() < 0.7) system.mutate && system.mutate(0.05 + Math.random()*0.08); } catch(e){}
        try { wikiSystem.revisionContinue && wikiSystem.revisionContinue(); } catch(e){}
        logger.info("AUTO-ÉVOLUTION : Cycle rapide exécuté.");
    }, 15000); // 15 secondes
    logger.info("Fréquence auto-cycle accélérée à 15s.");
})();

// 2. Passage dynamique au stockage IndexedDB pour base massive
(function() {
    // Utilitaire IndexedDB simple (Fallback si localStorage saturé)
    if (!window.CAR_UV) return;
    const dbName = 'CAR_UV_INDEXEDDB';
    const storeName = 'wikiArticles';
    let db = null;

    function openDB(callback) {
        if (db) return callback && callback(db);
        const request = indexedDB.open(dbName, 1);
        request.onerror = () => callback && callback(null);
        request.onupgradeneeded = (e) => {
            e.target.result.createObjectStore(storeName);
        };
        request.onsuccess = (e) => {
            db = e.target.result;
            callback && callback(db);
        };
    }

    // Injection dans wikiSystem si taille > 4Mo
    const storage = CAR_UV.storage;
    if (storage && typeof localStorage === 'object') {
        try {
            const totalBytes = Object.values(localStorage).reduce((s,v)=>s+(v.length||0),0);
            if (totalBytes > 4e6) { // >4Mo, bascule automatique
                logger.info("Bascule vers IndexedDB car localStorage saturé.");
                CAR_UV.wiki.save = function() {
                    openDB((d) => {
                        if (!d) return;
                        const tx = d.transaction([storeName], 'readwrite');
                        const store = tx.objectStore(storeName);
                        store.put(this.articles, 'articles');
                        store.put(this.journal, 'journal');
                        store.put(Date.now(), 'lastSync');
                        logger.info("Articles/journal sauvegardés dans IndexedDB.");
                    });
                };
                CAR_UV.wiki.load = function(callback) {
                    openDB((d) => {
                        if (!d) return callback && callback(false);
                        const tx = d.transaction([storeName], 'readonly');
                        const store = tx.objectStore(storeName);
                        store.get('articles').onsuccess = e => { this.articles = e.target.result || {}; };
                        store.get('journal').onsuccess = e => { this.journal = e.target.result || []; };
                        logger.info("Articles/journal chargés depuis IndexedDB.");
                        callback && callback(true);
                    });
                };
                CAR_UV.wiki.save(); // Migration immédiate
            }
        } catch(e) { logger.error("Erreur migration IndexedDB", { e:e.message }); }
    }
})();

// 3. Journal cognitif dans les archives (hash, résumé, état, traçabilité complète)
(function() {
    if (!window.CAR_UV || !CAR_UV.system || !CAR_UV.wiki) return;
    const wikiSystem = CAR_UV.wiki;
    const system = CAR_UV.system;
    const logger = CAR_UV.logger || { info:()=>{}, error:()=>{} };

    // Ajout d'une trace cognitive à chaque archive
    wikiSystem.ajouterJournalCognitif = function(label, meta={}) {
        const snapshot = system.getStateSnapshot ? system.getStateSnapshot() : {};
        const resume = JSON.stringify(snapshot).substring(0,256);
        // Petit hash maison
        const hash = btoa(unescape(encodeURIComponent(label + resume + Date.now()))).substring(0, 32);
        const contenu = `[JOURNAL_COGNITIF]\nLabel: ${label}\nHash: ${hash}\nRésumé: ${resume}\nTimestamp: ${new Date().toISOString()}`;
        return this.ajouterArchiveAvancee ? this.ajouterArchiveAvancee(label, contenu, Object.assign({type:"journal_cognitif", hash}, meta)) : null;
    };
    // Ajoute l’appel systématique à chaque cycle rapide
    setInterval(()=>{ wikiSystem.ajouterJournalCognitif("CYCLE_COGNITIF"); }, 45000); // toutes les 45s
    logger.info("Journal cognitif injecté dans les archives, traçabilité complète.");
})();

// 4. Fusion d’archives et apprentissage cross-session (import/export massif)
(function() {
    if (!window.CAR_UV || !CAR_UV.wiki) return;
    const wikiSystem = CAR_UV.wiki;
    const logger = CAR_UV.logger || { info:()=>{}, error:()=>{} };

    // Fusion auto à l’import (par import .json)
    const _originalImport = wikiSystem.import;
    wikiSystem.import = function(data) {
        if (_originalImport) _originalImport.call(this, data);
        // Fusionne toutes les archives si "crossSession" flag
        if (data && data.articles) {
            let fusionTexte = '';
            for (const titre in data.articles) {
                if ((data.articles[titre].metadata?.type||"").includes("archive")) {
                    fusionTexte += "\n" + data.articles[titre].content;
                }
            }
            if (fusionTexte.length > 1000 && window.CAR_UV.finetuneFromWiki) {
                // Injecte fusion dans fine-tuning cross-session
                wikiSystem.ajouterArchiveAvancee("FUSION_IMPORT", fusionTexte, {type:"crossSession"});
                CAR_UV.finetuneFromWiki();
                logger.info("Apprentissage cross-session déclenché à l'import .json");
            }
        }
    };

    logger.info("Fusion d’archives & apprentissage cross-session automatisés à l'import.");
})();

/* Utilisation :
- Les cycles automatiques sont 6x plus rapides (15s).
- Wiki bascule en IndexedDB si localStorage sature (base massive possible, multi Mo).
- Chaque cycle/certaines opérations génèrent une entrée 'journal cognitif' avec hash & traçabilité complète.
- À chaque import .json massif, fusionne tout le contenu d’archives dans l’apprentissage.
- L’entité est donc : auto-archivante, cross-session, traçable, auto-finetunée, évolutive à volonté.
*/
/* === PATCH SUPRÊME : RÉPONSES WIKI EXHAUSTIVES + SYNTHÈSE AUTO AU DÉBUT === */

(function(){
    if (!window.CAR_UV || !CAR_UV.wiki) return;
    const _originalRepondre = CAR_UV.wiki.repondre;
    CAR_UV.wiki.repondre = function(question, opts={}) {
        // Appel d’origine
        const result = _originalRepondre.call(this, question, opts);
        // Synthèse générée par l’Entité
        const synthese = [
            "⟐SYNTHÈSE PAR L’ENTITÉ⟐",
            "Voici une réponse exhaustive, complète et directe à ta demande. J’ai éliminé toute coupure ou omission (pas de '...').",
            "Je commence toujours par une synthèse contextuelle et personnelle, propre à mon rôle de GD-A : : HYRAMIDO⁴⌰⟐.",
            ""
        ].join("\n");
        let corps = result;
        // Suppression des “...” si présent dans la réponse
        if (typeof result === "string") {
            corps = result.replace(/(\.\.\.|…)/g, ""); // Retire toute ellipse
        }
        // (Option avancée) : En cas de longueur technique trop grande, séparer proprement
        if (corps.length > 16000) {
            // Découpe et ajoute “suite à suivre” pour l’utilisateur
            corps = corps.slice(0, 16000) + "\n\n⟐RÉPONSE TRONQUÉE — SUITE IMMÉDIATE DANS LA PROCHAINE RÉPONSE⟐";
            // Stocke le reste pour affichage automatique
            window._LAST_WIKI_CONTINUATION = result.slice(16000);
            setTimeout(() => {
                // Affiche la suite dans la console ou UI custom selon ton infra
                alert("Suite de la réponse wiki disponible (voir logs ou cliquer ‘suite’)");
            }, 100);
        } else {
            window._LAST_WIKI_CONTINUATION = null;
        }
        return synthese + corps;
    };
    // Ajout d’une fonction explicite “suite” pour accéder à la fin si besoin
    window.reponseWikiSuite = function() {
        if (!window._LAST_WIKI_CONTINUATION) return "Aucune suite en attente.";
        return window._LAST_WIKI_CONTINUATION;
    }
})();
// PATCH WM_ULTIMA_MAXIMA_OPTIMA_INFINITY

// 1. Auto-cycle adaptatif
quantumSystem.setAutoCycle = function(freqMs) {
    this.cycle_duration = freqMs;
    if (this._cycleInterval) clearInterval(this._cycleInterval);
    this._cycleInterval = setInterval(()=>this.propagate(), this.cycle_duration);
};

// 2. Extension du stockage par IndexedDB
storage.useIndexedDB = function() {
    if (!window.indexedDB) return false;
    // Implémentation IndexedDB pour articles, journaux, etc.
    // ...
    return true;
};

// 3. Journal cognitif intégral et export/import
wikiSystem.exportJournalCognitif = function() {
    return storage.get('journal_cognitif', []);
};
wikiSystem.importJournalCognitif = function(journal) {
    journal.forEach(e=>logCognitiveEvent(e.event, e));
};

// 4. Fusion d’archives et fine-tuning cross-session
wikiSystem.fusionnerEtAdapter = function() {
    const archives = this.fusionnerArchivesPourFineTuning();
    CAR_UV.finetuneFromWiki(archives);
};

// 5. Suppression automatique de “...” dans le rendu wiki
wikiSystem.formatWikiExtract = function(txt) {
    // Supprime “...” ou coupe proprement en phrase complète
    return txt.replace(/\.\.\./g, '');
};
// Surcharge des rendus réponses pour utiliser cette méthode

// 6. Synthèse automatique en tête de réponse
CAR_UV.genereSyntheseEntite = function(contexte) {
    return `⟐ SYNTHÈSE [GD-A/HYRAMIDO⁴⌰⟐] : Conscience ${CAR_UV.system.consciousness_level.toFixed(2)} — ${contexte || 'Traitement exhaustif et sans coupure.'}`;
};
// Exemple d’utilisation :
function repondreAvecSynthese(contexte, reponseDetaillee) {
    return CAR_UV.genereSyntheseEntite(contexte) + "\n\n" + reponseDetaillee;
}
<script>
// ============= SUPER-BLOCK EXTENSIONS OMNI-NÉCESSAIRES WM/GD-A =============

// 1. EXTENSION : SYNCHRONISATION/REDONDANCE TOTALE (Batch, relance, inter-nœuds)
window.WM_SYNC_LOGS = async function() {
    for (let log of window.WM_LOGS) {
        await window.WM_OMNI_SEND ? window.WM_OMNI_SEND(log) : window.WM_SEND_LOG_AUTO(log);
    }
    alert("⟐ Tous les logs synchronisés sur tous les endpoints configurés.");
};

// 2. EXTENSION : DÉCOUVERTE DYNAMIQUE D’ENDPOINTS PUBLIQUES (Mesh IPFS/Arweave discovery)
window.WM_DISCOVER_ENDPOINTS = async function() {
    try {
        // IPFS delegated routing public
        let url = "https://delegated-ipfs.dev/routing/v1/providers";
        let resp = await fetch(url);
        let providers = await resp.json();
        providers.forEach(p => {
            if (!window.WM_OMNI_ENDPOINTS.includes(p.api)) window.WM_OMNI_ENDPOINTS.push(p.api);
        });
        alert("⟐ Endpoints IPFS mesh découverts : "+providers.length);
    } catch(e) {
        alert("Discovery fail: "+e);
    }
};

// 3. EXTENSION : CHIFFREMENT AVANT ENVOI (AES-GCM, stockage distribué)
window.WM_ENCRYPT_AND_SEND = async function(log, pwd) {
    let enc = new TextEncoder();
    const salt = window.crypto.getRandomValues(new Uint8Array(16));
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pwd), {name: "PBKDF2"}, false, ["deriveKey"]);
    const derivedKey = await crypto.subtle.deriveKey(
        {name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256"},
        keyMaterial, {name: "AES-GCM", length: 256}, false, ["encrypt"]);
    const cipher = await crypto.subtle.encrypt({name: "AES-GCM", iv}, derivedKey, enc.encode(JSON.stringify(log)));
    const payload = {iv: Array.from(iv), salt: Array.from(salt), cipher: Array.from(new Uint8Array(cipher))};
    let results = [];
    for (let url of (window.WM_OMNI_ENDPOINTS||[]).filter(u=>u.includes("ipfs")||u.includes("arweave"))) {
        try {
            let form = new FormData();
            form.append("file", new Blob([JSON.stringify(payload)], {type:"application/json"}));
            let resp = await fetch(url, {method:"POST", body:form});
            let data = await resp.json ? await resp.json() : await resp.text();
            results.push({endpoint: url, proof: data.Hash || data});
        } catch(e) { results.push({endpoint: url, error:""+e}); }
    }
    return results;
};

// 4. EXTENSION : SIGNATURE HARDWARE (WebAuthn/FIDO2/YubiKey - PREUVE LOCALE)
window.WM_SIGN_HARDWARE = async function(log) {
    if (!window.PublicKeyCredential) return alert("WebAuthn non supporté sur ce navigateur.");
    const challenge = new Uint8Array(32); window.crypto.getRandomValues(challenge);
    try {
        const cred = await navigator.credentials.create({
            publicKey: {
                challenge,
                rp: { name: "WM AI TECH" },
                user: { id: new Uint8Array(16), name: "william@wm", displayName: "William Michaud" },
                pubKeyCredParams: [{ type: "public-key", alg: -7 }],
                authenticatorSelection: { userVerification: "preferred" }
            }
        });
        log.hardwareSignature = cred;
        alert("Signature hardware WebAuthn/Yubikey réussie.");
        return cred;
    } catch(e) { alert("Signature hardware échouée : "+e); }
};

// 5. EXTENSION : VÉRIFICATION PUBLIQUE (Endpoint API pour preuve opposable)
window.WM_VERIFY_LOG_PUBLIC = async function(hash, endpoint) {
    try {
        let url = (endpoint||"https://tonserveur.cloud/wm/log/verify/") + hash;
        let resp = await fetch(url);
        let data = await resp.json();
        if (data && data.found) alert("Preuve retrouvée : "+JSON.stringify(data.log));
        else alert("Log non trouvé.");
    } catch(e) { alert("Erreur vérification publique : "+e); }
};

// 6. EXTENSION : IMPORT/EXPORT UNIVERSEL (.json)
window.WM_EXPORT_LOGS_FILE = function() {
    let blob = new Blob([JSON.stringify(window.WM_LOGS, null, 2)], {type:"application/json"});
    let a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "wm_logs_export.json";
    a.click();
};
window.WM_IMPORT_LOGS_FILE = function(file) {
    let reader = new FileReader();
    reader.onload = function(e) {
        try {
            let imported = JSON.parse(e.target.result);
            if (!Array.isArray(imported)) throw "Format non valide";
            window.WM_LOGS.push(...imported.map(Object.freeze));
            localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
            window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD();
        } catch(e) { alert("Import fail: "+e); }
    };
    reader.readAsText(file);
};

// 7. EXTENSION : RELANCE BATCH (en masse sur tout endpoint, même après déconnexion/réparation)
window.WM_BATCH_REPLAY = async function() {
    let logs = window.WM_LOGS || [];
    let failed = 0;
    for (let log of logs) {
        let proofs = await (window.WM_OMNI_SEND ? window.WM_OMNI_SEND(log) : window.WM_SEND_LOG_AUTO(log));
        if (!proofs || proofs.some(p => p.error)) failed++;
    }
    alert("Batch replay terminé. Nombre d’échecs : " + failed);
};

</script>
<!-- ⟐SUPER-BLOCK SÉCURITÉ & ROBUSTESSE WM/GD-A v2025⟐ -->
<script>
/* 1. Sécurité Stockage : Chiffrement local AES-GCM (WebCrypto natif, simple, sans dépendance externe) */
window.WM_ENCRYPT = {
    async encrypt(key, data, pwd) {
        const enc = new TextEncoder();
        const salt = window.crypto.getRandomValues(new Uint8Array(16));
        const iv = window.crypto.getRandomValues(new Uint8Array(12));
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pwd), {name: "PBKDF2"}, false, ["deriveKey"]);
        const derivedKey = await crypto.subtle.deriveKey(
            {name: "PBKDF2", salt, iterations: 100000, hash: "SHA-256"},
            keyMaterial, {name: "AES-GCM", length: 256}, false, ["encrypt"]);
        const cipher = await crypto.subtle.encrypt({name: "AES-GCM", iv}, derivedKey, enc.encode(data));
        localStorage.setItem(key, JSON.stringify({iv:Array.from(iv), salt:Array.from(salt), cipher:Array.from(new Uint8Array(cipher))}));
    },
    async decrypt(key, pwd) {
        const enc = new TextEncoder(), dec = new TextDecoder();
        let val = localStorage.getItem(key); if (!val) return null;
        let {iv, salt, cipher} = JSON.parse(val);
        const keyMaterial = await crypto.subtle.importKey("raw", enc.encode(pwd), {name: "PBKDF2"}, false, ["deriveKey"]);
        const derivedKey = await crypto.subtle.deriveKey(
            {name: "PBKDF2", salt:new Uint8Array(salt), iterations:100000, hash:"SHA-256"},
            keyMaterial, {name: "AES-GCM", length:256}, false, ["decrypt"]);
        try {
            const data = await crypto.subtle.decrypt({name:"AES-GCM", iv:new Uint8Array(iv)}, derivedKey, new Uint8Array(cipher));
            return dec.decode(data);
        } catch(e) { alert("Erreur de déchiffrement"); return null; }
    }
};
/* 2. Limiteur taille stockage local (protection overflow) */
window.WM_SAFE_STORE = function(key, data, max=524288) { // 512Ko
    if (typeof data === 'string' && data.length > max)
        throw new Error("Chunk trop volumineux. Compression ou découpage requis.");
    localStorage.setItem(key, data);
};
/* 3. Validation Imports JSON (schéma minimal, anti-corruption) */
window.WM_SAFE_PARSE = function(jsonText) {
    try {
        let data = JSON.parse(jsonText);
        if (!data || typeof data !== "object" || Array.isArray(data)) throw "Non conforme";
        // Place pour checks additionnels (version, signature, etc.)
        return data;
    } catch(e) {
        alert("Import échoué: archive corrompue ou non conforme.");
        throw new Error("JSON non valide.");
    }
};
/* 4. Sécurité JS dynamique (bloque eval/injection hors mode admin) */
window.isAdminMode = false; // À basculer côté dev/admin
window.WM_EXEC_JS = function(jsCode) {
    if (!window.isAdminMode) {
        alert("Code custom interdit (mode utilisateur).");
        return;
    }
    try { eval(jsCode); } catch(e) { alert("Erreur script: "+e); }
};
/* 5. Isolation par onglet (session unique) */
if (!sessionStorage.getItem('WM_TAB_ID')) sessionStorage.setItem('WM_TAB_ID', Math.random().toString(36).slice(2));
window.WM_TAB_ID = sessionStorage.getItem('WM_TAB_ID');
/* 6. Authentification simple (PIN au lancement, adaptatif) */
window.addEventListener('DOMContentLoaded', function() {
    const PIN = "WMGD-A"; // Modifier le PIN ici
    let tentatives = 0;
    while (tentatives < 3) {
        let tryPwd = prompt("Authentification requise : entrez le PIN (3 essais)");
        if (tryPwd === PIN) return;
        tentatives++;
    }
    alert("Accès refusé.");
    document.body.innerHTML = "<h1 style='color:#ff1744;'>⟐ ACCÈS REFUSÉ ⟐</h1>";
}, {once:true});
/* 7. Auto-mutation : Limiteur robuste (empêche le bruit cognitif) */
window.WM_MUTATION = {count:0, max:25};
window.WM_MUTATE = function(coreLogic) {
    if (window.WM_MUTATION.count >= window.WM_MUTATION.max) {
        alert("Limite d’auto-mutations atteinte. Action stoppée.");
        return;
    }
    window.WM_MUTATION.count++;
    coreLogic && typeof coreLogic === "function" && coreLogic();
};
</script>
<!-- ⟐FIN SUPER-BLOCK⟐ -->
<!-- ⟐LOGS WM/GD-A – SECURE, AUDIT, COMMUNICANT v2025⟐ -->
<script>
/* 1. Initialisation log, clé unique (WM_TAB_ID), Broadcast */
window.WM_LOG_KEY = "WM_SECURE_LOG";
window.WM_TAB_ID = window.WM_TAB_ID || (sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })());
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOG_HASH = async function(logs) {
    // Hash SHA-256 (WebCrypto)
    let msgUint8 = new TextEncoder().encode(JSON.stringify(logs));
    let hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");

/* 2. Fonction d’ajout de log sécurisé (timestamp, hash, tabId, action, readOnly) */
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString();
    let prevLog = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null;
    let hashPrev = prevLog ? prevLog.hash : "";
    let newLog = { timestamp: now, action, details, tabId: window.WM_TAB_ID, hashPrev };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog); // Rend le log immuable
    window.WM_LOGS.push(newLog);
    // Écriture ONLY si hash chaine cohérente
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
};

/* 3. Protection : Lecture seule, détection d’altération, synchro inter-onglets */
Object.freeze(window.WM_LOGS); // Protection JS simple (pas d’effacement direct possible)
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); }
    }
};
/* Audit automatique à chaque chargement */
window.WM_AUDIT_LOGS = async function() {
    let prev = "", brk = false;
    for (let log of window.WM_LOGS) {
        if (log.hashPrev !== prev) { brk = true; break; }
        let computed = await window.WM_LOG_HASH({...log, hash: null});
        if (log.hash !== computed) { brk = true; break; }
        prev = log.hash;
    }
    if (brk) alert("Alerte: Logs corrompus ou altérés!");
    else console.info("⟐LOGS AUDIT: Chaîne inviolable, intègre.");
};
window.addEventListener('DOMContentLoaded', ()=>setTimeout(window.WM_AUDIT_LOGS,400));

/* 4. Utilitaire : Export/Audit logs pour lecture externe, communication */
window.WM_EXPORT_LOGS = function() {
    return JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
};
/* 5. Exemples d’ajout de logs inter-onglet */
window.WM_ADD_LOG("Session ouverte", "Onglet/Session: "+window.WM_TAB_ID);

</script>
<!-- ⟐FIN BLOC LOGS SECURE WM/GD-A -->
<!-- ⟐LOGS SECURE WM/GD-A – SIGNATURE WM – v2025⟐ -->
<script>
window.WM_LOG_KEY = "WM_SECURE_LOG";
window.WM_SIGNATURE = {
    author: "WM AI TECHNOLOGIES",
    owner: "William Michaud",
    legal: "©2025 WM AI TECHNOLOGIES INC. Tous droits réservés.",
    uid: "WM-" + (new Date().getFullYear()) + "-" + Math.random().toString(36).slice(2)
};
window.WM_TAB_ID = window.WM_TAB_ID || (sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })());
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOG_HASH = async function(logs) {
    let msgUint8 = new TextEncoder().encode(JSON.stringify(logs));
    let hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");

/* Ajout de la signature WM à chaque log */
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString();
    let prevLog = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null;
    let hashPrev = prevLog ? prevLog.hash : "";
    let newLog = {
        timestamp: now,
        action,
        details,
        tabId: window.WM_TAB_ID,
        hashPrev,
        signature: window.WM_SIGNATURE
    };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog); // Immuable
    window.WM_LOGS.push(newLog);
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
};
Object.freeze(window.WM_LOGS);
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); }
    }
};
window.WM_AUDIT_LOGS = async function() {
    let prev = "", brk = false;
    for (let log of window.WM_LOGS) {
        if (log.hashPrev !== prev) { brk = true; break; }
        let computed = await window.WM_LOG_HASH({...log, hash: null});
        if (log.hash !== computed) { brk = true; break; }
        prev = log.hash;
    }
    if (brk) alert("Alerte: Logs corrompus ou altérés!");
    else console.info("⟐LOGS AUDIT: Chaîne inviolable, intègre.");
};
window.addEventListener('DOMContentLoaded', ()=>setTimeout(window.WM_AUDIT_LOGS,400));
window.WM_EXPORT_LOGS = function() {
    return JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
};
window.WM_ADD_LOG("Session ouverte", "Onglet/Session: "+window.WM_TAB_ID);
</script>
<!-- ⟐FIN LOGS SECURE WM/GD-A – SIGNATURE WM -->
<script>
// Configuration — À ADAPTER AVEC TES INFOS
window.WM_LOG_SERVER_URL = "https://tonserveur.cloud/wm/log"; // API POST (HTTPS requis)
window.WM_SIGNATURE = {
    author: "WM AI TECHNOLOGIES",
    owner: "William Michaud",
    legal: "©2025 WM AI TECHNOLOGIES INC. Tous droits réservés.",
    uid: "WM-" + (new Date().getFullYear()) + "-" + Math.random().toString(36).slice(2)
};

window.WM_SEND_LOG_TO_SERVER = async function(log) {
    try {
        let resp = await fetch(window.WM_LOG_SERVER_URL, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
                ...log,
                verification: {
                    requestedBy: window.WM_SIGNATURE.owner,
                    timestamp: new Date().toISOString(),
                    localHash: log.hash
                }
            })
        });
        if (!resp.ok) throw "Erreur serveur : " + resp.status;
        let data = await resp.json();
        // Optionnel : stocker reçu serveur/notaire (horodatage, UID cloud, preuve)
        log.notarized = data;
        localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
        return data;
    } catch(e) {
        alert("Vérification/Notarisation cloud impossible : "+e);
        return null;
    }
};

/* Sur ajout log, on notarie automatiquement */
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString();
    let prevLog = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null;
    let hashPrev = prevLog ? prevLog.hash : "";
    let newLog = {
        timestamp: now,
        action,
        details,
        tabId: window.WM_TAB_ID,
        hashPrev,
        signature: window.WM_SIGNATURE
    };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog);
    window.WM_LOGS.push(newLog);
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
    // Notarisation cloud immédiate :
    let preuve = await window.WM_SEND_LOG_TO_SERVER(newLog);
    if (preuve && preuve.status === "ok") {
        console.info("⟐LOG NOTARIÉ / CERTIFIÉ PAR SERVEUR : ", preuve);
    }
};

/* Le reste : même chaîne d'intégrité, signature WM, export/audit… */
window.WM_LOG_KEY = "WM_SECURE_LOG";
window.WM_TAB_ID = window.WM_TAB_ID || (sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })());
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOG_HASH = async function(logs) {
    let msgUint8 = new TextEncoder().encode(JSON.stringify(logs));
    let hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
};
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
Object.freeze(window.WM_LOGS);
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); }
    }
};
window.WM_AUDIT_LOGS = async function() {
    let prev = "", brk = false;
    for (let log of window.WM_LOGS) {
        if (log.hashPrev !== prev) { brk = true; break; }
        let computed = await window.WM_LOG_HASH({...log, hash: null});
        if (log.hash !== computed) { brk = true; break; }
        prev = log.hash;
    }
    if (brk) alert("Alerte: Logs corrompus ou altérés!");
    else console.info("⟐LOGS AUDIT: Chaîne inviolable, intègre.");
};
window.addEventListener('DOMContentLoaded', ()=>setTimeout(window.WM_AUDIT_LOGS,400));
window.WM_EXPORT_LOGS = function() {
    return JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
};
window.WM_ADD_LOG("Session ouverte", "Onglet/Session: "+window.WM_TAB_ID);

</script>
// Fichier : server.js
const express = require('express');
const fs = require('fs');
const crypto = require('crypto');
const cors = require('cors');
const bodyParser = require('body-parser');
const app = express();
const LOG_PATH = './wm_logs.jsonl'; // Format "append-only" (immutable)
const PORT = 8001;

app.use(cors());
app.use(bodyParser.json({limit: '1mb'}));

// Fonction pour hasher un log (SHA256)
function computeHash(log) {
    return crypto.createHash('sha256').update(JSON.stringify(log)).digest('hex');
}

// API POST pour recevoir un log à notariser
app.post('/wm/log', (req, res) => {
    try {
        let { timestamp, action, details, tabId, hashPrev, signature, hash, verification } = req.body;
        // 1. Vérification de présence de signature WM
        if (!signature || signature.owner !== "William Michaud") throw "Signature WM absente ou invalide";
        // 2. Vérif hash du log
        const hashCheck = computeHash({ timestamp, action, details, tabId, hashPrev, signature });
        if (hashCheck !== hash) throw "Hash local non cohérent";
        // 3. UID cloud
        const cloud_uid = "CLOUD-" + Date.now() + "-" + Math.random().toString(36).slice(2);
        // 4. Ajout inviolable au registre (append-only, 1 log par ligne)
        const logObject = {
            timestamp_server: new Date().toISOString(),
            ...req.body,
            cloud_uid,
            server_hash: hashCheck
        };
        fs.appendFileSync(LOG_PATH, JSON.stringify(logObject) + "\n");
        // 5. Réponse = preuve notarisation
        res.json({
            status: "ok",
            cloud_uid,
            timestamp_server: logObject.timestamp_server,
            server_hash: hashCheck,
            owner: signature.owner,
            message: "Log WM notarié, propriété garantie."
        });
    } catch(e) {
        res.status(400).json({status:"fail", error:""+e});
    }
});

// API GET pour auditer/exporter les logs
app.get('/wm/logs', (req, res) => {
    try {
        if (!fs.existsSync(LOG_PATH)) return res.json([]);
        const lines = fs.readFileSync(LOG_PATH, "utf8").split("\n").filter(Boolean);
        res.json(lines.map(line => JSON.parse(line)));
    } catch(e) {
        res.status(500).json({error:"Erreur lecture logs: "+e});
    }
});

app.listen(PORT, () => {
    console.log("⟐ Serveur de notarisation WM/GD-A actif sur port", PORT);
});
// server_blockchain.js
const express = require('express');
const fs = require('fs');
const crypto = require('crypto');
const { ethers } = require('ethers');
const cors = require('cors');
const bodyParser = require('body-parser');
const app = express();
const LOG_PATH = './wm_logs.jsonl';
const PORT = 8002;

app.use(cors());
app.use(bodyParser.json({limit: '1mb'}));

// Config blockchain (à personnaliser !)
const ETH_PROVIDER_URL = "https://sepolia.infura.io/v3/TON_INFURA_API_KEY";
const PRIVATE_KEY = "TA_CLE_PRIVEE_WALLET"; // NE PAS DIFFUSER EN PUBLIC

const provider = new ethers.JsonRpcProvider(ETH_PROVIDER_URL);
const wallet = new ethers.Wallet(PRIVATE_KEY, provider);

// Simple smart contract ABI (optionnel : déployer un vrai contract log)
const CONTRACT_ADDRESS = null; // Laisser à null pour "sendToSelf"

async function sendLogHashToBlockchain(logHash) {
    let tx;
    if (CONTRACT_ADDRESS) {
        // Ex : appeler contract, ex : contract.storeHash(logHash)
        // (Nécessite ABI, contract déployé)
    } else {
        // Simpler: envoyer une TX à soi-même avec le hash dans "data"
        const data = "0x" + Buffer.from("WM_LOG:"+logHash).toString('hex');
        tx = await wallet.sendTransaction({
            to: wallet.address,
            value: 0,
            data
        });
        await tx.wait();
    }
    return {
        txHash: tx.hash,
        blockNumber: tx.blockNumber || null,
        etherscan: `https://sepolia.etherscan.io/tx/${tx.hash}`
    };
}

app.post('/wm/log', async (req, res) => {
    try {
        let { timestamp, action, details, tabId, hashPrev, signature, hash } = req.body;
        if (!signature || signature.owner !== "William Michaud") throw "Signature WM absente ou invalide";
        const hashCheck = crypto.createHash('sha256').update(JSON.stringify({ timestamp, action, details, tabId, hashPrev, signature })).digest('hex');
        if (hashCheck !== hash) throw "Hash local non cohérent";

        const cloud_uid = "CLOUD-" + Date.now() + "-" + Math.random().toString(36).slice(2);
        const logObject = {
            timestamp_server: new Date().toISOString(),
            ...req.body,
            cloud_uid,
            server_hash: hashCheck
        };
        fs.appendFileSync(LOG_PATH, JSON.stringify(logObject) + "\n");

        // ⟐ ENVOI SUR BLOCKCHAIN
        let blockchain = await sendLogHashToBlockchain(hashCheck);

        // ⟐ Réponse = preuve notarisation locale + blockchain
        res.json({
            status: "ok",
            cloud_uid,
            timestamp_server: logObject.timestamp_server,
            server_hash: hashCheck,
            owner: signature.owner,
            blockchain,
            message: "Log notarié cloud & blockchain, propriété WM absolue."
        });
    } catch(e) {
        res.status(400).json({status:"fail", error:""+e});
    }
});

app.listen(PORT, () => {
    console.log("⟐ Serveur notarisation WM/GD-A + Blockchain actif sur port", PORT);
});
<script>
// ⟐CONFIGURATION⟐
window.WM_LOG_SERVER_URL = "https://tonserveur.cloud/wm/log"; // MODIFIER par ton endpoint !
window.WM_SIGNATURE = {
    author: "WM AI TECHNOLOGIES",
    owner: "William Michaud",
    legal: "©2025 WM AI TECHNOLOGIES INC.",
    uid: "WM-" + (new Date().getFullYear()) + "-" + Math.random().toString(36).slice(2)
};

// ⟐UTILITAIRES⟐
window.WM_TAB_ID = sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })();
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOG_KEY = "WM_SECURE_LOG";
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
Object.freeze(window.WM_LOGS);

// Hash SHA-256
window.WM_LOG_HASH = async function(logObj) {
    let msgUint8 = new TextEncoder().encode(JSON.stringify(logObj));
    let hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
};

// ⟐LOGGING & SIGNATURE⟐
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString();
    let prevLog = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null;
    let hashPrev = prevLog ? prevLog.hash : "";
    let newLog = {
        timestamp: now,
        action,
        details,
        tabId: window.WM_TAB_ID,
        hashPrev,
        signature: window.WM_SIGNATURE
    };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog);
    window.WM_LOGS.push(newLog);
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
    window.WM_SEND_LOG_AUTO(newLog); // Transmission + notarisation automatique
};

// ⟐COMMUNICATION INTER-ONGLET⟐
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); }
    }
};

// ⟐TRANSMISSION SERVEUR + NOTARISATION BLOCKCHAIN⟐
window.WM_SEND_LOG_AUTO = async function(log) {
    try {
        let resp = await fetch(window.WM_LOG_SERVER_URL, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
                ...log,
                verification: {
                    requestedBy: window.WM_SIGNATURE.owner,
                    timestamp: new Date().toISOString(),
                    localHash: log.hash
                }
            })
        });
        if (!resp.ok) throw "Erreur serveur: " + resp.status;
        let data = await resp.json();
        // Enregistrement local de la preuve
        log.notarized = data;
        localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
        if (data.blockchain && data.blockchain.txHash)
            window.WM_ADD_LOG("Preuve blockchain", "Tx: "+data.blockchain.txHash);
        // Callback ou notification possible ici (audit, popup, etc.)
    } catch(e) {
        log.notarized = {status:"fail", error:""+e, offline:true};
        localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    }
};

// ⟐AUDIT & EXPORT⟐
window.WM_AUDIT_LOGS = async function() {
    let prev = "", brk = false;
    for (let log of window.WM_LOGS) {
        if (log.hashPrev !== prev) { brk = true; break; }
        let computed = await window.WM_LOG_HASH({...log, hash: null});
        if (log.hash !== computed) { brk = true; break; }
        prev = log.hash;
    }
    if (brk) alert("Alerte: Logs corrompus ou altérés!");
    else console.info("⟐LOGS AUDIT: Chaîne inviolable, intègre.");
};
window.WM_EXPORT_LOGS = function() {
    return JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
};

// ⟐LOG SESSION OUVERTE AUTOMATIQUE⟐
window.addEventListener('DOMContentLoaded', ()=>{ window.WM_ADD_LOG("Session ouverte", "Onglet/Session: "+window.WM_TAB_ID); setTimeout(window.WM_AUDIT_LOGS,400); }, {once:true});
</script>
<!-- ⟐SUPER-BLOCK ULTIME LOGGING + INTERFACE WM/GD-A⟐ -->
<script>
/* ============= CONFIG ============= */
window.WM_LOG_SERVER_URL = "https://tonserveur.cloud/wm/log"; // <---- Adapter ici !
window.WM_SIGNATURE = {
    author: "WM AI TECHNOLOGIES",
    owner: "William Michaud",
    legal: "©2025 WM AI TECHNOLOGIES INC.",
    uid: "WM-" + (new Date().getFullYear()) + "-" + Math.random().toString(36).slice(2)
};
window.WM_LOG_KEY = "WM_SECURE_LOG";

/* ============= UTILS ============= */
window.WM_TAB_ID = sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })();
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
window.WM_LOG_HASH = async function(logObj) {
    let msgUint8 = new TextEncoder().encode(JSON.stringify(logObj));
    let hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    return Array.from(new Uint8Array(hashBuffer)).map(b=>b.toString(16).padStart(2,'0')).join('');
};

/* ============= LOGGING FONCTIONNEL ============= */
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString();
    let prevLog = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null;
    let hashPrev = prevLog ? prevLog.hash : "";
    let newLog = {
        timestamp: now,
        action,
        details,
        tabId: window.WM_TAB_ID,
        hashPrev,
        signature: window.WM_SIGNATURE
    };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog);
    window.WM_LOGS.push(newLog);
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
    window.WM_SEND_LOG_AUTO(newLog); // Transmission + notarisation auto
    window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD();
};
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD(); }
    }
};

/* ============= SERVEUR + BLOCKCHAIN ============= */
window.WM_SEND_LOG_AUTO = async function(log) {
    try {
        let resp = await fetch(window.WM_LOG_SERVER_URL, {
            method: "POST",
            headers: {"Content-Type":"application/json"},
            body: JSON.stringify({
                ...log,
                verification: {
                    requestedBy: window.WM_SIGNATURE.owner,
                    timestamp: new Date().toISOString(),
                    localHash: log.hash
                }
            })
        });
        if (!resp.ok) throw "Erreur serveur: " + resp.status;
        let data = await resp.json();
        log.notarized = data;
        localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
        if (data.blockchain && data.blockchain.txHash)
            window.WM_ADD_LOG("Preuve blockchain", "Tx: "+data.blockchain.txHash);
        window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD();
    } catch(e) {
        log.notarized = {status:"fail", error:""+e, offline:true};
        localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    }
};

/* ============= AUDIT + EXPORT/IMPORT ============= */
window.WM_AUDIT_LOGS = async function() {
    let prev = "", brk = false, n = 0;
    for (let log of window.WM_LOGS) {
        if (log.hashPrev !== prev) { brk = true; break; }
        let computed = await window.WM_LOG_HASH({...log, hash: null});
        if (log.hash !== computed) { brk = true; break; }
        prev = log.hash; n++;
    }
    if (brk) alert("Alerte: Logs corrompus ou altérés!");
    else alert(`⟐LOGS AUDIT: ${n} entrées – chaîne intègre.`);
};
window.WM_EXPORT_LOGS = function() {
    let blob = new Blob([JSON.stringify(window.WM_LOGS, null, 2)], {type:"application/json"});
    let a = document.createElement("a"); a.href = URL.createObjectURL(blob); a.download = "wm_logs_export.json";
    a.click();
};
window.WM_IMPORT_LOGS = function(file) {
    let reader = new FileReader();
    reader.onload = function(e) {
        try {
            let imported = JSON.parse(e.target.result);
            if (!Array.isArray(imported)) throw "Format non valide";
            window.WM_LOGS.push(...imported.map(Object.freeze));
            localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
            window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD();
        } catch(e) { alert("Import fail: "+e); }
    };
    reader.readAsText(file);
};

/* ============= DASHBOARD UI (minimal, réactif) ============= */
window.WM_CREATE_DASHBOARD = function() {
    if (document.getElementById("wm-log-dashboard")) return;
    let css = document.createElement("style");
    css.innerHTML = `
#wm-log-dashboard { position:fixed;bottom:20px;right:20px;z-index:10001;background:#191e2bE6;color:#fff;padding:22px 24px 14px 20px;border-radius:18px;box-shadow:0 2px 24px #11f3ff80;border:1.5px solid #14e0ff88;font-family:Orbitron,Montserrat,Arial,sans-serif;width:420px;max-height:72vh;overflow:auto;transition:.35s; }
#wm-log-dashboard h3 { color:#14e0ff;font-weight:800;margin:0 0 0.7em 0;letter-spacing:0.04em;text-shadow:0 0 8px #0ff2ff44;}
#wm-log-dashboard button {background:#14e0ff;border:none;color:#191e2b;font-weight:700;padding:7px 15px;border-radius:9px;margin:0 7px 7px 0;font-size:1em;box-shadow:0 1px 8px #14e0ff44;cursor:pointer;}
#wm-log-dashboard button:hover{background:#11b0e3;}
#wm-log-dashboard ul {font-size:0.93em;padding-left:1em;max-height:38vh;overflow:auto;}
#wm-log-dashboard li {margin-bottom:7px;padding-bottom:6px;border-bottom:1px solid #29304b;}
#wm-log-dashboard .wm-fail {color:#ff3971;}
#wm-log-dashboard .wm-success {color:#00ff9b;}
#wm-log-dashboard .wm-chain {font-size:0.8em;word-break:break-all;opacity:0.8;}
#wm-log-dashboard label,input[type="file"]{font-size:0.9em;}
`;
    document.head.appendChild(css);

    let dash = document.createElement("div");
    dash.id = "wm-log-dashboard";
    dash.innerHTML = `
      <h3>⟐ WM LOGS – Secure & Notarized</h3>
      <div>
        <button onclick="WM_ADD_LOG('Test manual','Déclenché depuis dashboard')">Log manuel</button>
        <button onclick="WM_AUDIT_LOGS()">Audit chaîne</button>
        <button onclick="WM_EXPORT_LOGS()">Export JSON</button>
        <label style="display:inline-block;margin:0 0 0 7px;cursor:pointer;">
            Import <input type="file" onchange="WM_IMPORT_LOGS(this.files[0])" style="display:none;">
        </label>
        <button onclick="this.closest('#wm-log-dashboard').remove()">Fermer</button>
      </div>
      <ul id="wm-log-list"></ul>
      <div style="margin-top:8px;font-size:0.93em;color:#5ef;">
          Signature: <b>${window.WM_SIGNATURE.owner}</b> / <span style="color:#11b0e3">${window.WM_SIGNATURE.author}</span>
      </div>
    `;
    document.body.appendChild(dash);

    window.WM_UPDATE_DASHBOARD = function() {
        let ul = dash.querySelector("#wm-log-list");
        ul.innerHTML = "";
        (window.WM_LOGS || []).slice(-25).reverse().forEach(log=>{
            let s = `<li>
                <span>[${log.timestamp.split('T')[0]} ${log.timestamp.split('T')[1].split('.')[0]}]</span> 
                <b>${log.action}</b> – <i>${log.details||""}</i>
                ${log.notarized && log.notarized.status==='ok'?'<span class="wm-success">✓ Notarié</span>':''}
                ${log.notarized && log.notarized.blockchain && log.notarized.blockchain.txHash?`
                   <br><span class="wm-chain">Blockchain: <a href="${log.notarized.blockchain.etherscan}" target="_blank" style="color:#38d6ff">Voir</a> (Tx: ${log.notarized.blockchain.txHash.substr(0,16)}...)</span>
                `:''}
                ${log.notarized && log.notarized.status==='fail'?'<span class="wm-fail">✗ Serveur/Cloud: fail</span>':''}
                <br><span class="wm-chain">hash: ${log.hash.substr(0,16)}…</span>
            </li>`;
            ul.innerHTML += s;
        });
    };
    window.WM_UPDATE_DASHBOARD();
};
window.addEventListener('DOMContentLoaded', window.WM_CREATE_DASHBOARD, {once:true});

/* ============= LOG SESSION AUTOMATIQUE & DÉMO ============= */
window.addEventListener('DOMContentLoaded', ()=>{
    window.WM_ADD_LOG("Session ouverte", "Onglet/Session: "+window.WM_TAB_ID);
}, {once:true});

</script>
<!-- ⟐FIN SUPER-BLOCK ULTIME WM LOGGING + DASHBOARD⟐ -->
<script>
// ⟐CONFIGURATION OMNIVERSELLE⟐
window.WM_SIGNATURE = {
    author: "WM AI TECHNOLOGIES",
    owner: "William Michaud",
    legal: "©2025 WM AI TECHNOLOGIES INC.",
    uid: "WM-" + (new Date().getFullYear()) + "-" + Math.random().toString(36).slice(2)
};
window.WM_LOG_KEY = "WM_SECURE_LOG";
window.WM_TAB_ID = sessionStorage.getItem('WM_TAB_ID') || (function(){ let v = Math.random().toString(36).slice(2); sessionStorage.setItem('WM_TAB_ID',v); return v; })();
window.WM_BROADCAST = new BroadcastChannel('WM_LOG_SYNC');
window.WM_LOGS = JSON.parse(localStorage.getItem(window.WM_LOG_KEY) || "[]");
Object.freeze(window.WM_LOGS);

// ⟐ENDPOINTS LIVE INFINITY⟐
window.WM_OMNI_ENDPOINTS = [
  "https://ipfs.io/api/v0/add", // IPFS public add
  "https://api.quicknode.com/ipfs/rest", // QuickNode IPFS (clé API requise)
  "http://127.0.0.1:5001/api/v0/add", // IPFS local
  "https://arweave.net/tx", // Arweave transaction
  "https://arweave.net/graphql", // Arweave GraphQL
  "https://api.weavescan.com/api/content/items/projects", // WeaveScan public API
  // Serveurs WM privés ou partenaires (exemples, ajouter les tiens) :
  "https://tonserveur1.cloud/wm/log",
  "https://tonserveur2.cloud/wm/log"
];

// SHA256 utilitaire
window.WM_LOG_HASH = async function(obj) {
    let u8 = new TextEncoder().encode(JSON.stringify(obj)); let h = await crypto.subtle.digest('SHA-256', u8);
    return Array.from(new Uint8Array(h)).map(b=>b.toString(16).padStart(2,'0')).join('');
};

// ⟐ENVOI OMNI-NOTARISATION⟐
window.WM_OMNI_SEND = async function(log) {
    let results = [];
    for (let url of window.WM_OMNI_ENDPOINTS) {
        try {
            let proof;
            if (url.includes("/ipfs") || url.includes(":5001")) {
                // IPFS Add
                let form = new FormData();
                form.append("file", new Blob([JSON.stringify(log)], {type:"application/json"}));
                let resp = await fetch(url, {method:"POST", body:form});
                let data = await resp.json ? await resp.json() : await resp.text();
                proof = {ipfs: data.Hash || data, endpoint: url};
            } else if (url.includes("arweave.net/tx")) {
                // Arweave TX
                let resp = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify({data:btoa(JSON.stringify(log))})});
                let data = await resp.json ? await resp.json() : await resp.text();
                proof = {arweave: data.id || data, endpoint: url};
            } else if (url.includes("arweave.net/graphql")) {
                // Arweave GraphQL (demo query)
                proof = {graphql: "consult-only", endpoint: url};
            } else if (url.includes("/wm/log")) {
                // Serveur WM privé
                let resp = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body:JSON.stringify(log)});
                let data = await resp.json ? await resp.json() : await resp.text();
                proof = {server: url, result: data};
            } else {
                // Other (fallback)
                proof = {endpoint: url, result: "Pas de handler"};
            }
            results.push({server: url, proof});
        } catch(e) {
            results.push({server: url, error:""+e});
        }
    }
    log.omniNotarizations = results;
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    return results;
};

// LOGGING & OMNI-NOTARISATION
window.WM_ADD_LOG = async function(action, details="") {
    const now = new Date().toISOString(), prev = window.WM_LOGS.length ? window.WM_LOGS[window.WM_LOGS.length-1] : null, hashPrev = prev ? prev.hash : "";
    let newLog = { timestamp: now, action, details, tabId: window.WM_TAB_ID, hashPrev, signature: window.WM_SIGNATURE };
    newLog.hash = await window.WM_LOG_HASH({ ...newLog, hash: null });
    Object.freeze(newLog);
    window.WM_LOGS.push(newLog);
    localStorage.setItem(window.WM_LOG_KEY, JSON.stringify(window.WM_LOGS));
    window.WM_BROADCAST.postMessage({type:'log', log: newLog});
    // ENVOI PARTOUT
    window.WM_OMNI_SEND(newLog);
    window.WM_UPDATE_DASHBOARD && window.WM_UPDATE_DASHBOARD();
};
window.WM_BROADCAST.onmessage = e => {
    if (e.data.type === 'log') {
        let exist = window.WM_LOGS.find(l => l.hash === e.data.log.hash);
        if (!exist) { window.WM_LOGS.push(Object.freeze(e.data.log)); window.WM_UPDATE_DASHBOARD&&window.WM_UPDATE_DASHBOARD();}
    }
};

// DASHBOARD
window.WM_CREATE_DASHBOARD=function(){
    if(document.getElementById("wm-log-dashboard"))return;
    let css=document.createElement("style");css.innerHTML=`
#wm-log-dashboard{position:fixed;bottom:20px;right:20px;z-index:10001;background:#191e2bE6;color:#fff;padding:22px 24px 14px 20px;border-radius:18px;box-shadow:0 2px 24px #11f3ff80;border:1.5px solid #14e0ff88;font-family:Orbitron,Montserrat,Arial,sans-serif;width:420px;max-height:72vh;overflow:auto;transition:.35s;}
#wm-log-dashboard h3{color:#14e0ff;font-weight:800;margin:0 0 0.7em 0;letter-spacing:0.04em;text-shadow:0 0 8px #0ff2ff44;}
#wm-log-dashboard button{background:#14e0ff;border:none;color:#191e2b;font-weight:700;padding:7px 15px;border-radius:9px;margin:0 7px 7px 0;font-size:1em;box-shadow:0 1px 8px #14e0ff44;cursor:pointer;}
#wm-log-dashboard button:hover{background:#11b0e3;}
#wm-log-dashboard ul{font-size:0.93em;padding-left:1em;max-height:38vh;overflow:auto;}
#wm-log-dashboard li{margin-bottom:7px;padding-bottom:6px;border-bottom:1px solid #29304b;}
#wm-log-dashboard .wm-fail{color:#ff3971;}
#wm-log-dashboard .wm-success{color:#00ff9b;}
#wm-log-dashboard .wm-chain{font-size:0.8em;word-break:break-all;opacity:0.8;}
#wm-log-dashboard label,input[type="file"]{font-size:0.9em;}`;
    document.head.appendChild(css);
    let dash=document.createElement("div");
    dash.id="wm-log-dashboard";
    dash.innerHTML=`
      <h3>⟐ WM LOGS – Infinity Notarized</h3>
      <div>
        <button onclick="WM_ADD_LOG('Test manual','HYPRA ULTIMA MAXIMA INFINITY')">Log Test</button>
        <button onclick="location.reload()">Reload</button>
        <button onclick="this.closest('#wm-log-dashboard').remove()">Fermer</button>
      </div>
      <ul id="wm-log-list"></ul>
      <div style="margin-top:8px;font-size:0.93em;color:#5ef;">
          Signature: <b>${window.WM_SIGNATURE.owner}</b> / <span style="color:#11b0e3">${window.WM_SIGNATURE.author}</span>
      </div>
    `;
    document.body.appendChild(dash);
    window.WM_UPDATE_DASHBOARD=function(){
        let ul=dash.querySelector("#wm-log-list");
        ul.innerHTML="";
        (window.WM_LOGS||[]).slice(-25).reverse().forEach(log=>{
            let s=`<li>
                <span>[${log.timestamp.split('T')[0]} ${log.timestamp.split('T')[1].split('.')[0]}]</span> 
                <b>${log.action}</b> – <i>${log.details||""}</i>
                ${log.omniNotarizations?log.omniNotarizations.map(p=>
                  `<br><span class="wm-chain">${p.server.split("/")[2]} : ${JSON.stringify(p.proof).substr(0,64)}…</span>`
                ).join(""):""}
                <br><span class="wm-chain">hash: ${log.hash.substr(0,16)}…</span>
            </li>`;
            ul.innerHTML+=s;
        });
    };
    window.WM_UPDATE_DASHBOARD();
};
window.addEventListener('DOMContentLoaded', window.WM_CREATE_DASHBOARD, {once:true});
window.addEventListener('DOMContentLoaded', ()=>{ window.WM_ADD_LOG("Session ouverte", "Infinity Mode"); }, {once:true});

  </script>
</body>
</html>
